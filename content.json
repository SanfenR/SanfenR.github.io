{"meta":{"title":"SanfenR的博客","subtitle":null,"description":"大成若缺, 大直若屈, 大巧若拙, 大智若愚。","author":"SanfenR","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"解决java.lang.SecurityException","slug":"java/解决java.lang.SecurityException","date":"2017-10-09T16:00:00.000Z","updated":"2017-10-10T12:32:38.000Z","comments":true,"path":"2017/10/10/java/解决java.lang.SecurityException/","link":"","permalink":"http://yoursite.com/2017/10/10/java/解决java.lang.SecurityException/","excerpt":"","text":"解决java.lang.SecurityException: Invalid signature file digest for Manifest main attributes当项目依赖其他jar包的时候，打出的jar包执行出错，抛出这个异常。 原因：因为依赖jar包中的META-INF中有多余的.SF文件与当前jar包冲突， 解决方案 一 1在打包前删除依赖jar包的.SF文件 解决方案 二 123在打完的jar包执行zip -d your.jar &apos;META-INF/.SF&apos; &apos;META-INF/.RSA&apos; &apos;META-INF/*SF&apos;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"git命令","slug":"git命令","date":"2017-04-11T16:00:00.000Z","updated":"2017-04-24T12:13:34.000Z","comments":true,"path":"2017/04/12/git命令/","link":"","permalink":"http://yoursite.com/2017/04/12/git命令/","excerpt":"","text":"1.1git init #初始化本地git仓库（创建新仓库） 2.1git config --global user.name &quot;xxx&quot; # 配置用户名 3.1git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件 4.1git config --global color.ui true # git status等命令自动着色 5.1git config --global color.status auto 6.1git config --global color.diff auto 7.1git config --global color.branch auto 8.1git config --global color.interactive auto 9.1git config --global --unset http.proxy # remove proxy configuration on git 10.1git clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库 11.1git status # 查看当前版本状态（是否修改） 12.1git add xyz # 添加xyz文件至index 13.1git add . # 增加当前子目录下所有更改过的文件至index 14.1git commit -m &apos;xxx&apos; # 提交 15.1git commit --amend -m &apos;xxx&apos; # 合并上一次提交（用于反复修改） 16.1git commit -am &apos;xxx&apos; # 将add和commit合为一步 17.1git rm xxx # 删除index中的文件 18.1git rm -r * # 递归删除 19.1git log # 显示提交日志 20.1git log -1 # 显示1行日志 -n为n行 21.1git log -5 22.1git log --stat # 显示提交日志及相关变动文件 23.1git log -p -m 24.1git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容 25.1git show dfb02 # 可只用commitid的前几位 26.1git show HEAD # 显示HEAD提交日志 27.1git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本 28.1git tag # 显示已存在的tag 29.1git tag -a v2.0 -m &apos;xxx&apos; # 增加v2.0的tag 30.1git show v2.0 # 显示v2.0的日志及详细内容 31.1git log v2.0 # 显示v2.0的日志 32.1git diff # 显示所有未添加至index的变更 33.1git diff --cached # 显示所有已添加index但还未commit的变更 34.1git diff HEAD^ # 比较与上一个版本的差异 35.1git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异 36.1git diff origin/master..master #比较远程分支master上有本地分支master上没有的 37.1git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 38.1git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch） 39.1git branch # 显示本地分支 40.1git branch --contains 50089 # 显示包含提交50089的分支 41.1git branch -a # 显示所有分支 42.1git branch -r # 显示所有原创分支 43.1git branch --merged # 显示所有已合并到当前分支的分支 44.1git branch --no-merged # 显示所有未合并到当前分支的分支 45.1git branch -m master master_copy # 本地分支改名 46.1git checkout -b master_copy # 从当前分支创建新分支master_copy并检出 47.1git checkout -b master master_copy # 上面的完整版 48.1git checkout features/performance # 检出已存在的features/performance分支 49.1git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支 50.1git checkout v2.0 # 检出版本v2.0 51.1git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出 52.1git checkout -- README # 检出head版本的README文件（可用于修改错误回退） 53.1git merge origin/master # 合并远程master分支至当前分支 54.1git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 55.1git push origin master # 将当前分支push到远程master分支 56.1git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支 57.1git push --tags # 把所有tag推送到远程仓库 58.1git fetch # 获取所有远程分支（不更新本地分支，另需merge） 59.1git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支 60.1git pull origin master # 获取远程分支master并merge到当前分支 61.1git mv README README2 # 重命名文件README为README2 62.1git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） 63.1git rebase 64.1git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支） 65.1git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 66.1git ls-files # 列出git index包含的文件 67.1git show-branch # 图示当前分支历史 68.1git show-branch --all # 图示所有分支历史 69.1git whatchanged # 显示提交历史对应的文件修改 70.1git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818 71.1git ls-tree HEAD # 内部命令：显示某个git对象 72.1git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASH 73.1git reflog # 显示所有提交，包括孤立节点 74.1git show HEAD@&#123;5&#125; 75.1git show master@&#123;yesterday&#125; # 显示master分支昨天的状态 76.1git log --pretty=format:&apos;%h %s&apos; --graph # 图示提交日志 77.1git show HEAD~3 78.1git show -s --pretty=raw 2be7fcb476 79.1git stash # 暂存当前修改，将所有至为HEAD状态 80.1git stash list # 查看所有暂存 81.1git stash show -p stash@&#123;0&#125; # 参考第一次暂存 82.1git stash apply stash@&#123;0&#125; # 应用第一次暂存 83.1git grep &quot;delete from&quot; # 文件中搜索文本“delete from” 84.1git grep -e &apos;#define&apos; --and -e SORT_DIRENT 85.1git gc 86.1git fsck 87.1git log --oneline --abbrev-commit --all --graph --decorate --color # 显示所有branch提交历史图 88.1git checkout --patch commitid filename # 合并指定commit的指定文件","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Android修改包名","slug":"android/Android修改包名","date":"2017-04-10T16:00:00.000Z","updated":"2017-04-12T12:33:05.000Z","comments":true,"path":"2017/04/11/android/Android修改包名/","link":"","permalink":"http://yoursite.com/2017/04/11/android/Android修改包名/","excerpt":"","text":"优雅的修改包名 在开发中碰到修改包名的时候，需要修改许多文件，下面演示一种比较方便的修改包名的方法。 在项目列表中取消勾选Compact Empty Middle Package 取消勾选显示出项目的所有目录结构 修改包名 修改gradle中的包名 修改完成。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Homebrew常用操作","slug":"Homebrew常用操作","date":"2017-04-06T16:00:00.000Z","updated":"2017-04-12T12:33:32.000Z","comments":true,"path":"2017/04/07/Homebrew常用操作/","link":"","permalink":"http://yoursite.com/2017/04/07/Homebrew常用操作/","excerpt":"","text":"Homebrew 更新Homebrew 更新包 (formula)) 清理旧版本 锁定不想更新的包 其他几个常用命令 更新Homebrew要获取最新的包的列表，首先得更新 Homebrew 自己。这可以用 brew update 办到。1brew update 更新包(formula)要获取最新的包的列表，首先得更新 Homebrew 自己。这可以用 brew update 办到。1brew outdated 更新需要更新的包 12brew upgrade # 更新所有的包brew upgrade $FORMULA # 更新指定的包 清理旧版本一般情况下，新版本安装了，旧版本就不需要了。我会用brew cleanup 清理旧版本和缓存文件。Homebrew 只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。123brew cleanup # 清理所有包的旧版本brew cleanup $FORMULA # 清理指定包的旧版本brew cleanup -n # 查看可清理的旧版本包，不执行实际操作 锁定不想更新的包如果经常更新的话，brew update 一次更新所有的包是非常方便的。但我们有时候会担心自动升级把一些不希望更新的包更新了。数据库就属于这一类，尤其是 PostgreSQL 跨 minor 版本升级都要迁移数据库的。我们更希望找个时间单独处理它。这时可用 brew pin 去锁定这个包，然后 brew update 就会略过它了。 12brew pin $FORMULA # 锁定某个包brew unpin $FORMULA # 取消锁定 其他几个常用命令brew info 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 launchctl ，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。 12brew info $FORMULA # 显示某个包的信息brew info # 显示安装了包数量，文件数量，和总占用空间 brew deps 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。 1brew deps --installed --tree # 查看已安装的包的依赖，树形显示","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"四月","slug":"essay/四月","date":"2017-04-04T16:00:00.000Z","updated":"2017-04-12T12:33:24.000Z","comments":true,"path":"2017/04/05/essay/四月/","link":"","permalink":"http://yoursite.com/2017/04/05/essay/四月/","excerpt":"","text":"在 Android Studio 上调试数据库 ( SQLite ) 以前 Eclipse 时代，调试 SQLite 都是将数据库文件导出到电脑，然后再用软件打开查看。现在我们用 Android Studio，有没有更方便的方法呢？ 详解7.0带来的新工具类：DiffUtil DiffUtil是support-v7:24.2.0中的新工具类，它用来比较两个数据集，寻找出旧数据集-》新数据集的最小变化量。说到数据集，相信大家知道它是和谁相关的了，就是我的最爱，RecyclerView。就我使用的这几天来看，它最大的用处就是在RecyclerView刷新时，不再无脑mAdapter.notifyDataSetChanged()。","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"http://yoursite.com/tags/essay/"}]},{"title":"ActivityManager判断app运行状态","slug":"android/ActivityManager检测Service与Activity是否正在运行","date":"2017-02-27T16:00:00.000Z","updated":"2017-02-28T13:08:31.000Z","comments":true,"path":"2017/02/28/android/ActivityManager检测Service与Activity是否正在运行/","link":"","permalink":"http://yoursite.com/2017/02/28/android/ActivityManager检测Service与Activity是否正在运行/","excerpt":"","text":"摘要: 在后台与网络交互中，需要使用Service来和服务器保持连接，因此Service在被进程Kill掉后，主动开启Service是必要的，因此首先的检测Service是否已启动 检测Service是否已启动1234567891011public static boolean isServiceRunning(String serviceClassName)&#123; final ActivityManager activityManager = (ActivityManager)Application.getContext().getSystemService(Context.ACTIVITY_SERVICE); final List&lt;RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE); for (RunningServiceInfo runningServiceInfo : services) &#123; if (runningServiceInfo.service.getClassName().equals(serviceClassName))&#123; return true; &#125; &#125; return false; &#125; 检测Activity是否已启动12&lt;!-- 权限--&gt;&lt;uses-permission android:name=\"android.permission.GET_TASKS\"/&gt; 1234567891011ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);List&lt;RunningTaskInfo&gt; list = am.getRunningTasks(100);boolean isAppRunning = false;String MY_PKG_NAME = \"com.cyberblue.iitag\";for (RunningTaskInfo info : list) &#123; if (info.topActivity.getPackageName().equals(MY_PKG_NAME) || info.baseActivity.getPackageName().equals(MY_PKG_NAME)) &#123; isAppRunning = true; Log.i(TAG,info.topActivity.getPackageName() + \" info.baseActivity.getPackageName()=\"+info.baseActivity.getPackageName()); break; &#125;&#125; 1234567891011121314151617private boolean isLauncherRunnig(Context context) &#123; boolean result = false ; List&lt;String&gt; names = getAllTheLauncher(); ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE) ; List&lt;ActivityManager.RunningAppProcessInfo&gt; appList = mActivityManager.getRunningAppProcesses() ; for (RunningAppProcessInfo running : appList) &#123; if (running.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123; for (int i = 0; i &lt; names.size(); i++) &#123; if (names.get(i).equals(running.processName)) &#123; result = true ; break; &#125; &#125; &#125; &#125; return result ;&#125; 判断App是否运行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /** * 判断app是否正在运行 * @param ctx * @param packageName * @return */public boolean appIsRunning(Context ctx,String packageName)&#123; ActivityManager am = (ActivityManager) ctx.getSystemService(ACTIVITY_SERVICE); List&lt;RunningAppProcessInfo&gt; runningAppProcesses = am.getRunningAppProcesses(); if(runningAppProcesses!=null) &#123; for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) &#123; if(runningAppProcessInfo.processName.startsWith(packageName)) &#123; return true; &#125; &#125; &#125; return false;&#125;/** * app 是否在后台运行 * @param ctx * @param packageName * @return */public boolean appIsBackgroundRunning(Context ctx,String packageName)&#123; ActivityManager am = (ActivityManager) ctx.getSystemService(ACTIVITY_SERVICE); List&lt;RunningAppProcessInfo&gt; runningAppProcesses = am.getRunningAppProcesses(); if(runningAppProcesses!=null) &#123; for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) &#123; if(runningAppProcessInfo.processName.startsWith(packageName)) &#123; return runningAppProcessInfo.importance!=RunningAppProcessInfo.IMPORTANCE_FOREGROUND &amp;&amp; runningAppProcessInfo.importance!=RunningAppProcessInfo.IMPORTANCE_VISIBLE; //排除无界面的app &#125; &#125; &#125; return false;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"合并已经排序的2条链表(day11)","slug":"everydayc/day11","date":"2017-02-12T16:00:00.000Z","updated":"2017-02-28T13:16:08.000Z","comments":true,"path":"2017/02/13/everydayc/day11/","link":"","permalink":"http://yoursite.com/2017/02/13/everydayc/day11/","excerpt":"","text":"题目 合并2条链表1如 1，3，5，7 和 2，4，6，8 -&gt; 1,2,3,4,5,6,7,8 实现1234567891011121314151617181920212223242526272829303132333435363738ListNode * mergeList(ListNode* list1, ListNode* list2)&#123; if(!list1) return list2; if(!list2) return list1; ListNode* head; ListNode* tail = new ListNode(); head = tail; while(list1 || list2) &#123; if(!list2 || list1-&gt;value &lt; list2-&gt;value) &#123; tail-&gt;next = list1; tail=tail-&gt;next; list1=list1-&gt;next; &#125; else &#123; tail-&gt;next=list2; tail=tail-&gt;next; list2=list2-&gt;next; &#125; &#125; return head-&gt;next;&#125;//使用递归ListNode * mergeList2(ListNode* list1, ListNode* list2)&#123; if(!list1) return list2; if(!list2) return list1; ListNode* head; if(list1-&gt;value &lt; list2-&gt;value)&#123; head = list1; head-&gt;next = mergeList2(list1-&gt;next, list2); &#125; else&#123; head = list2; head-&gt;next = mergeList2(list1,list2-&gt;next); &#125; return head;&#125; 源码传送门","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"打印1到最大的n位数(day10)","slug":"everydayc/day10","date":"2017-01-19T16:00:00.000Z","updated":"2017-02-28T13:16:04.000Z","comments":true,"path":"2017/01/20/everydayc/day10/","link":"","permalink":"http://yoursite.com/2017/01/20/everydayc/day10/","excerpt":"","text":"题目 打印1到最大的n位数。如n=4，打印1-9999。 思路 如果直接使用循环会导致int或者long都不够存储，因此使用string来存储数据，这里涉及到字符串以及字符串的加法。 实现1234567891011121314151617181920212223242526void print(const int &amp;n) &#123; if (n &lt;= 0) &#123; return; &#125; char *number = new char[n + 1]; memset(number, '0', (n + 1) * sizeof(char)); number[n] = '\\0'; printMax(number, 0, n); delete[] number;&#125;void printMax(char *number, const int index, const int size) &#123; if (!number) return; if (index == size) &#123;//嵌套截止条件 cout &lt;&lt; number &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; 10; i++) &#123; number[index] = (char) (i + '0');//index---当前调整的位数 printMax(number, index + 1, size); &#125;&#125; 源码传送门","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android-Fragment懒加载","slug":"android/lazyfragment使用","date":"2017-01-10T16:00:00.000Z","updated":"2017-01-12T09:56:56.000Z","comments":true,"path":"2017/01/11/android/lazyfragment使用/","link":"","permalink":"http://yoursite.com/2017/01/11/android/lazyfragment使用/","excerpt":"","text":"ViewPager的预加载在项目中，经常会遇到ViewPager+TabLayout实现对多个fragment的管理。但是由于ViewPager的预加载(默认的预加载为1)，viewpager会调用fragment的onCreateView()进行fragmemt的初始化: 而在Android中当fragment的onCreateView()会将整个xml文件中的UI控件实例到内存，而且数据的请求初始化基本也是在onCreateView()中进行。导致App启动的时候加载的数据过多。 解决方案解决这个问题有两种方式，一种是禁止ViewPager的预加载，重写ViewPager,但是该方法会出现左右滑动时会出现卡顿现象，带来不好的用户体验。而另外一种就是我们接下来要讲的通过Fragment的懒加载来实现。当用户切换到某个fragment时再加载。 setUserVisibleHint()方法懒加载主要使用到fragment中的setUserVisibleHint()，这个方法是当fragment的UI显示状态变化时会被调用。源码如下：123456789101112131415161718192021222324/** * Set a hint to the system about whether this fragment's UI is currently visible * to the user. This hint defaults to true and is persistent across fragment instance * state save and restore. * * &lt;p&gt;An app may set this to false to indicate that the fragment's UI is * scrolled out of visibility or is otherwise not directly visible to the user. * This may be used by the system to prioritize operations such as fragment lifecycle updates * or loader ordering behavior.&lt;/p&gt; * * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method may be called outside of the fragment lifecycle. * and thus has no ordering guarantees with regard to fragment lifecycle method calls.&lt;/p&gt; * * @param isVisibleToUser true if this fragment's UI is currently visible to the user (default), * false if it is not. */public void setUserVisibleHint(boolean isVisibleToUser) &#123; if (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED &amp;&amp; mFragmentManager != null &amp;&amp; isAdded()) &#123; mFragmentManager.performPendingDeferredStart(this); &#125; mUserVisibleHint = isVisibleToUser; mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser;&#125; 实现 因为fragment的onCreateView()方法会将xml中的控件加载到内存中，所以我们定义一个空的FragmentLayout。 创建一个空的容器作为预加载界面1234567&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/other_frame\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.mz.sanfen.lazyfragment.OtherFragment\"&gt;&lt;/FrameLayout&gt; 并在onCreateView()中初始化这个布局 123456789@Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View inflate = inflater.inflate(R.layout.fragment_other, container, false); frameLayout = (FrameLayout) inflate.findViewById(R.id.one_frame); Log.e(TAG, \"onCreateView: \" + frameLayout ); return inflate; &#125; 将具体的内容的UI定义到一个子xml中，并在setUserVisibleHint()方法中进行初始化控件和数据加载，并将这个xml放入外部的容器中。 重新创建一个子布局1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/other_text\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"@string/hello_blank_fragment\" /&gt;&lt;/LinearLayout&gt; 并在setUserVisibleHint()中进行初始化123456789101112 @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser);// Log.e(TAG, \"setUserVisibleHint: \" + isVisibleToUser ); if (isVisibleToUser) &#123; if (contentView == null ) &#123; contentView = LayoutInflater.from(getActivity()).inflate(R.layout.content_other, frameLayout, true); textView = (TextView) contentView.findViewById(R.id.other_text); textView.setText(\"load other fragment\"); &#125; &#125; &#125; 注意ViewPager在预加载fragment的时候是先调用setUserVisibleHint(), 然后再是调用onCreateView()方法。 源码传送门","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"和为n的连续正数序列(day9)","slug":"everydayc/day9","date":"2017-01-07T16:00:00.000Z","updated":"2017-02-28T13:15:03.000Z","comments":true,"path":"2017/01/08/everydayc/day9/","link":"","permalink":"http://yoursite.com/2017/01/08/everydayc/day9/","excerpt":"","text":"题目 题目：输入一个正数n，输出所有和为n 连续正数序列。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以输出3 个连续序列1-5、4-6 和7-8。 思路 对于固定的left.当前sum值小于目标Sum，则right一直后移 sum==Sum。则输出序列，且将right后移 对于固定的right.,sum&gt;Sum时，始终将left左移动 实现12345678910111213141516171819202122232425void print(const int &amp;left, const int &amp;right) &#123; static int flag = 0; cout &lt;&lt; \"NO:\" &lt;&lt; ++flag &lt;&lt; \"--\"; for (int i = left; i &lt;= right; ++i) &#123; cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void findSequence(const int &amp;Sum) &#123; int left = 1, right = 1, sum = 1; while (left &lt;= Sum / 2) &#123; if (sum == Sum) &#123; print(left, right); right++; sum += right; &#125; else if (sum &gt; Sum) &#123; sum -= left; left++; &#125; else &#123; right++; sum += right; &#125; &#125;&#125; 简略写法：123456789101112131415void findSequence(const int&amp; Sum) &#123; int left =1, right = 1, sum = 1; while(left &lt;= Sum/2) &#123; while (sum &gt; Sum) &#123; sum -= left; left ++; &#125; if (sum == Sum) &#123; print(left, right); &#125; right ++; sum += right; &#125;&#125; 拓展 题目：输入两个整数n和m，从数列1,2,3…n中随意取几个数，使其和等于m，要求列出所有的组合。 12345678910111213141516171819list&lt;int&gt; list1;void find_factor(int sum, int n) &#123; //递归出口 if (n &lt;= 0 || sum &lt; 0) return; //输出找到的数 if (sum == n) &#123; list1.reverse(); for (list&lt;int&gt;::iterator iter = list1.begin(); iter != list1.end(); iter++) cout &lt;&lt; *iter &lt;&lt; \" + \"; cout &lt;&lt; n &lt;&lt; endl; list1.reverse(); &#125; list1.push_front(n); find_factor(sum - n, n - 1);//n参与查找 list1.pop_front();&#125; 源码传送门","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android动态修改icon","slug":"android/Android动态修改icon","date":"2017-01-06T16:00:00.000Z","updated":"2017-01-10T03:18:36.000Z","comments":true,"path":"2017/01/07/android/Android动态修改icon/","link":"","permalink":"http://yoursite.com/2017/01/07/android/Android动态修改icon/","excerpt":"","text":"activity-alias使用 以前装应用的时候有些应用会在桌面上生成两个图标,这两个图标有些是同一个Activity的入口,有些是另外一个Activity的入口,这样的效果是怎么实现的呢?在看Android原生DeskClock程序的时候看到了这个功能的实现.使用的是activity-alias： 123456789&lt;activity-alias android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permission=\"string\" android:targetActivity=\"string\" &gt; . . .&lt;/activity-alias&gt; activity-alias中标记了一个名为android.intent.category.DESK_DOCK的category, 这个是在android设备插上桌面Dock底座的时候才会触发alias入口。设置: 1&lt;category android:name=\"android.intent.category.DESK_DOCK\" /&gt; 实现app多入口登入。 manifest代码：123456789101112131415161718192021&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity-alias android:name=\".icon_2\" android:enabled=\"true\" android:icon=\"@mipmap/steam_icon_72px\" android:label=\"@string/app_name\" android:targetActivity=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;category android:name=\"android.intent.category.DESK_DOCK\" /&gt; &lt;/intent-filter&gt;&lt;/activity-alias&gt; 效果如下：app显示了2个应用图标 app实现动态修改icon 了解完 的基本知识之后，就知道动态修改桌面图标和应用名称是怎么做到的了。其实就是给整个应用的入口 Activity 添加一个 标签，并设置预先设计好的替代桌面图标和应用名称，并配置相同的 属性，动态启动即可。 manifest代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;!--&lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;--&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity-alias android:name=\".icon_1\" android:enabled=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:targetActivity=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; &lt;activity-alias android:name=\".icon_2\" android:enabled=\"false\" android:icon=\"@mipmap/steam_icon_72px\" android:label=\"@string/app_name\" android:targetActivity=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt;&lt;/application&gt; Java代码123456789101112131415161718192021222324252627282930313233 private void setIcon(int useCode)&#123; try &#123; //要跟manifest的activity-alias 的name保持一致 String icon_1 = \"com.mz.sanfen.appicon.icon_1\"; String icon_2 = \"com.mz.sanfen.appicon.icon_2\"; if (useCode != 3) &#123; PackageManager pm = getPackageManager(); ComponentName normalComponentName = new ComponentName(getBaseContext(), icon_1); //正常图标新状态 int normalNewState = useCode == 1 ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED; if (pm.getComponentEnabledSetting(normalComponentName) != normalNewState) &#123;//新状态跟当前状态不一样才执行 pm.setComponentEnabledSetting( normalComponentName, normalNewState, PackageManager.DONT_KILL_APP); &#125; ComponentName actComponentName = new ComponentName(getBaseContext(), icon_2); //正常图标新状态 int actNewState = useCode == 2 ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED; if (pm.getComponentEnabledSetting(actComponentName) != actNewState) &#123;//新状态跟当前状态不一样才执行 pm.setComponentEnabledSetting( actComponentName, actNewState, PackageManager.DONT_KILL_APP); &#125; &#125; &#125; catch (Exception e) &#123; &#125;&#125; 在执行setIcon()之后，桌面会过一段时间显示新的图标，如果需要立即刷新图标，在执行setIcon()方法之后执行如下可以立即刷新。 12345678910Intent intent = new Intent(Intent.ACTION_MAIN);intent.addCategory(Intent.CATEGORY_HOME);intent.addCategory(Intent.CATEGORY_DEFAULT);List&lt;ResolveInfo&gt; resolves = getPackageManager().queryIntentActivities(intent, 0);for (ResolveInfo res : resolves) &#123; if (res.activityInfo != null) &#123; ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE); am.killBackgroundProcesses(res.activityInfo.packageName); &#125;&#125; 使用这个方法需要添加权限：1&lt;uses-permission android:name=\"android.permission.KILL_BACKGROUND_PROCESSES\"/&gt; 效果如下： 源码传送门","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Java中的阻塞队列","slug":"java/BlockingQueue","date":"2016-12-31T16:00:00.000Z","updated":"2017-01-09T06:37:25.000Z","comments":true,"path":"2017/01/01/java/BlockingQueue/","link":"","permalink":"http://yoursite.com/2017/01/01/java/BlockingQueue/","excerpt":"","text":"JAVA中的几种主要的阻塞队列 ArrayBlockingQueue: 基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象必须指定容量大小。并且可以指定公平性和非公平性，默认情况下为非公平性，即不保存等待时间最长的队列有限能够访问队列。 LinkedBlockingQueue: 基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象如果不指定容量大小，则为Integer.MAX_VALUE. PriorityBlockingQueue: 以上2种队列都是先进先出队列，而PriorityBlockQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限。 DelayQueue: 基于PriorityBlockingQueue: 基于PriortyQueue, 一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一种无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 阻塞队列的几个方法 put(E e): 向队尾存入元素，如果队列满了，则等待。 tack(): 从队首取元素，如果队伍为空，则等待。 offer(E e, long timeout, TimeUnil unit): 如果队列满了则等待一定时间，没有插入成功则返回false,成功则返回true. poll(long timeout, TimeUnit unit): 如果队列为空，则等待一定时间，当时间期限达到时，如果未取到，则返回null. 实现 阻塞队列实现 123456789101112131415161718192021222324252627282930313233343536373839public class BlockingQueue &#123; private List&lt;Object&gt; queue = new LinkedList&lt;&gt;(); private int limit = 10; public BlockingQueue(int limit)&#123; this.limit = limit; &#125; /** * 当队列满了的时候阻塞线程 * * @param item * @throws InterruptedException */ public synchronized void enqueue(Object item) throws InterruptedException &#123; while (this.queue.size() == this.limit) &#123; wait(); &#125; if (this.queue.size() &lt; this.limit) &#123; notifyAll(); &#125; this.queue.add(item); &#125; /** * 当队列为空的时候阻塞线程 * @return * @throws InterruptedException */ public synchronized Object dequeue() throws InterruptedException &#123; while (this.queue.size() == 0) &#123; wait(); &#125; if (this.queue.size() &gt; 1) &#123; notifyAll(); &#125; return this.queue.remove(0); &#125;&#125; 使用阻塞队列实现生产者消费者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ProducerConsumerPattern &#123; public static void main(String[] args) &#123; BlockingQueue shareQueue = new LinkedBlockingQueue&lt;&gt;(); Thread prodThread = new Thread(new Producer(shareQueue)); Thread consThread = new Thread(new Consumer(shareQueue)); prodThread.start(); consThread.start(); &#125; /** * 生产者 */ static class Producer implements Runnable &#123; private final BlockingQueue shareQueue; public Producer(BlockingQueue shareQueue) &#123; this.shareQueue = shareQueue; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++)&#123; System.out.println(\"Produced: \" + i); try &#123; shareQueue.put(i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者 */ static class Consumer implements Runnable &#123; private final java.util.concurrent.BlockingQueue shareQueue; public Consumer(BlockingQueue shareQueue) &#123; this.shareQueue = shareQueue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(\"Consumer: \" + shareQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 使用Lock和Condition实现阻塞队列 12345678910111213141516171819202122232425262728293031323334353637383940public class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 源码传送门","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"最大数对差(day8)","slug":"everydayc/day8","date":"2016-12-24T16:00:00.000Z","updated":"2016-12-27T09:49:38.000Z","comments":true,"path":"2016/12/25/everydayc/day8/","link":"","permalink":"http://yoursite.com/2016/12/25/everydayc/day8/","excerpt":"","text":"题目 题目：在数组中，数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如在数组{2, 4, 1, 16, 7, 5, 11, 9}中，数对之差的最大值是11，是16 减去5 的结果。 思路 Solution1: 将其转换成求最大子数组问题。引入辅助数组diff，长度为n-1。diff[i]=dif[i]-diff[i+1]。求出最大子数组以及位置low,high。则对应最大差为data[low]-data[high+1]。 Solution2: 使用动态规划法。假设data[i]减去某个数，其最大的数对差为currentMax。则data[i-1]的最大数对差为data[i-1]-data[i]和data[i-1]-data[i]+currentMax中的较大的那一个。从后往前遍历数组，记录最大的currentMax以及对应的low、high输出即可。时间复杂度O(n),空间复杂度O(1)。 实现123456789101112131415161718192021222324252627282930313233void fun(int data[], int size, int &amp;low, int &amp;high) &#123; int max = data[size - 1] - data[size - 2];//最大的数对差 int currentMax = data[size - 1] - data[size - 2];//当前的数对差 int l = size - 2; int h = size - 1; low = l;//被减数位置 high = h;//减数位置 for (int i = size - 3; i &gt;= 0; i--) &#123; if (currentMax &gt; 0) &#123; currentMax = data[i] - data[i + 1] + currentMax; l--; &#125; else &#123; currentMax = data[i] - data[i + 1]; l = i; h = i + 1; &#125; if (currentMax &gt; max) &#123; low = l; high = h; max = currentMax; &#125; &#125;&#125;void main() &#123; int data[] = &#123;2, 4, 1, 16, 7, 5, 11, 9&#125;; int low, high; fun(data, sizeof(data) / sizeof(int), low, high); cout &lt;&lt; \"the max is \" &lt;&lt; data[low] - data[high] &lt;&lt; endl;&#125; 源码传送门","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android中Canvas绘图(Shader)","slug":"android/Canvas中Shader的使用","date":"2016-12-21T16:00:00.000Z","updated":"2017-01-09T03:34:53.000Z","comments":true,"path":"2016/12/22/android/Canvas中Shader的使用/","link":"","permalink":"http://yoursite.com/2016/12/22/android/Canvas中Shader的使用/","excerpt":"","text":"简介 Shader就是着色器的意思。我们可以这样理解，Canvas中的各种drawXXX方法定义了图形的形状，画笔中的Shader则定义了图形的着色、外观，二者结合到一起就决定了最终Canvas绘制的被色彩填充的图形的样子。类android.graphics.Shader有五个子类，分别是：BitmapShader、LinearGradient、RadialGradient、SweepGradient和ComposeShader，下面依次对这几个类的使用分别说明。 BitmapShader BitmapShader，用Bitmap对绘制的图形进行渲染着色，其实就是用图片对图形进行贴图。 12//构造函数BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY) CLAMP: 当所画图形的尺寸大于Bitmap的尺寸的时候，会用Bitmap四边的颜色填充剩余空间。 REPEAT: 当我们绘制的图形尺寸大于Bitmap尺寸时，会用Bitmap重复平铺整个绘制的区域。 MIRROR: 当绘制的图形尺寸大于Bitmap尺寸时，MIRROR也会用Bitmap重复平铺整个绘图区域，与REPEAT不同的是，两个相邻的Bitmap互为镜像。 实现代码: 1234567891011121314private Shader.TileMode mDefaultTileMode = Shader.TileMode.REPEAT;public void drawBitmap()&#123; bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.music_player); BitmapShader bitmapShader = new BitmapShader(bitmap, mDefaultTileMode, mDefaultTileMode ); mPaint.setShader(bitmapShader);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawRect(0, 0, canvas.getWidth(), canvas.getHeight(), mPaint);&#125; 效果如下: LinearGradient LinearGradient, 是用来创建线性渐变效果的，它是沿着某条直线的方向渐变的，坐标(x0,y0)就是这条渐变直线的起点，坐标(x1,y1)就是这条渐变直线的终点。需要说明的是，坐标(x0,y0)和坐标(x1,y1)都是Canvas绘图坐标系中的坐标。color0和color1分别表示了渐变的起始颜色和终止颜色。与BitmapShader类似，LinearGradient也支持TileMode。 LinearGradient有以下三个取值：CLAMP 、REPEAT 和 MIRROR 12LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)LinearGradient(float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile) 12345678910111213141516private Shader.TileMode mDefaultTileMode = Shader.TileMode.REPEAT;@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawRect(0, 0, getWidth() , getHeight(), mPaint);&#125;public void drawLinear()&#123; LinearGradient linearGradient = new LinearGradient( 0, 0, getWidth() / 4, getHeight() / 4, Color.GREEN, Color.BLUE, mDefaultTileMode ); mPaint.setShader(linearGradient);&#125; 效果如下： RadialGradient RadialGradient 径向渐变，径向渐变说的简单点就是个圆形中心向四周渐变的效果 123RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) RadialGradient是用来创建从中心向四周发散的辐射渐变效果的，所以我们需要在其构造函数中传入一些圆的参数，坐标(centerX,centerY)是圆心，即起始的中心颜色的位置，radius确定了圆的半径，在圆的半径处的颜色是edgeColor，这样就确定了当位置从圆心移向圆的轮廓时，颜色逐渐从centerColor渐变到edgeColor。RadialGradient也支持TileMode参数，有以下三个取值：CLAMP 、REPEAT 和 MIRROR。 1234567891011121314@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawRect(0 , 0, getWidth(), getHeight(), mPaint);&#125;public void drawRadial()&#123; RadialGradient radial = new RadialGradient( getWidth() / 2, getHeight() / 2, getWidth() / 4, Color.YELLOW, Color.RED, mDefaultTileMode ); mPaint.setShader(radial);&#125; 效果如下： SweepGradientSweepGradient可以用来创建360度颜色旋转渐变效果，具体来说颜色是围绕中心点360度顺时针旋转的，起点就是3点钟位置。 SweepGradient, 梯度渐变，也称之为扫描式渐变，因为其效果有点类似雷达的扫描效果. 12SweepGradient(float cx, float cy, int color0, int color1)SweepGradient(float cx, float cy, int[] colors, float[] positions) SweepGradient不支持TileMode参数, 坐标(cx,cy)决定了中心点的位置，会绕着该中心点进行360度旋转。color0表示的是起点的颜色位置，color1表示的是终点的颜色位置。 123456789101112131415@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.drawCircle(getWidth() / 2, getHeight() / 2, getWidth() / 4, mPaint);&#125;public void drawSweep()&#123; //SweepGradient sweep = new SweepGradient(getWidth() /2, getHeight() / 2, Color.GREEN, Color.BLUE); int[] colors = &#123;Color.RED, Color.WHITE, Color.YELLOW&#125;; float[] positions = &#123;0f, 0.75f, 0f&#125;; SweepGradient sweep = new SweepGradient(getWidth() / 2 , getHeight() / 2, colors, positions); mPaint.setShader(sweep);&#125; 效果如下： 源码传送门 参考自定义控件其实很简单1/3 Android中Canvas绘图之Shader使用图文详解","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"二叉树中找出和为某一值的所有路径(day7)","slug":"everydayc/day7","date":"2016-12-20T16:00:00.000Z","updated":"2016-12-22T06:28:15.000Z","comments":true,"path":"2016/12/21/everydayc/day7/","link":"","permalink":"http://yoursite.com/2016/12/21/everydayc/day7/","excerpt":"","text":"题目 题目：输入一个整数和一棵二元树。从树的根结点开始往下访问一直到叶结点所经过的所有结点形成一条路径。打印出和与输入整数相等的所有路径。 123456789 例如输入整数22 和如下二元树 10 / \\ 5 12 / \\ 4 7则打印出两条路径：10, 12 和10, 5, 7。 思路 使用递归和栈结构。将当前路径保留在vector中。 对于空节点，返回false； 对于叶子节点，判断当前和是否为给定值，是则遍历输出栈中保存路径且返回true，否则返回false。 对于非叶子节点，将当前根节点入栈，先后递归左、右子树。且递归完后，要弹出栈中保存的当前路径。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Node &#123; int value; Node* left; Node* right;&#125;;bool decision(Node * head, int sum, vector&lt;int&gt; &amp;v)&#123; if(!head)&#123; return false; &#125; else if (!head-&gt;left &amp;&amp; !head-&gt;right)&#123; sum -= head-&gt;value; if(sum == 0)&#123; for (int i = 0; i &lt; v.size(); i++) &#123; cout &lt;&lt; v[i] &lt;&lt; endl; &#125; cout &lt;&lt; head-&gt;value &lt;&lt; \"\\n\" &lt;&lt; endl; &#125; return false; &#125; else &#123; v.push_back(head-&gt;value); sum -= head-&gt;value; bool left = decision(head-&gt;left, sum, v); bool right = decision(head-&gt;right, sum, v); v.pop_back(); if (left || right)&#123; return true; &#125; &#125; return false;&#125;int main()&#123; Node n4=&#123;4,NULL,NULL&#125;; Node n5=&#123;7,NULL,NULL&#125;; Node n3=&#123;12,NULL,NULL&#125;; Node n2=&#123;5,&amp;n4,&amp;n5&#125;; Node n1=&#123;10,&amp;n2,&amp;n3&#125;; vector&lt;int&gt; v; decision(&amp;n1,22,v); return 0;&#125; 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"java线程池源码分析","slug":"java/java-exectors","date":"2016-12-13T16:00:00.000Z","updated":"2017-01-12T10:08:16.000Z","comments":true,"path":"2016/12/14/java/java-exectors/","link":"","permalink":"http://yoursite.com/2016/12/14/java/java-exectors/","excerpt":"","text":"在什么情况下使用线程池 单个任务处理的时间比较短 将需处理的任务的数量大 使用线程池的好处 减少在创建和销毁线程上所花的时间以及系统资源的开销 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存以及”过度切换” 案例112345678910111213public class Main &#123; private static Executor executor = Executors.newFixedThreadPool(10); public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++)&#123; executor.execute(new Task()); &#125; &#125; private static class Task implements Runnable&#123; public void run()&#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; Executor.newFixedThreadPool(10)初始化一个包含10个线程的executor; 通过executor.execute方法提交20个任务 负责执行任务的生命周期都由Executor框架进行管理 ThreadPoolExecutorExecutor是java线程池的工厂类**，通过它可以快速初始化一个符合业务需求的线程池，如Excutor.newFixedThreadPool方法可以生成一个拥有固定线程数的线程池。 1234567891011121314151617181920212223242526272829303132/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory and rejected execution handler. * It may be more convenient to use one of the &#123;@link Executors&#125; factory * methods instead of this general purpose constructor. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 其本质是通过不同的参数初始化一个ThreadPoolExecutor对象，具体参数描述如下： corePoolSize线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。 keepAliveTime线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用。 unitkeepAliveTime的单位。 workQueue用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列： ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务； LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene； SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene； priorityBlockingQuene：具有优先级的无界阻塞队列； threadFactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。 12345678DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; handler线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： AbortPolicy：直接抛出异常，默认策略； CallerRunsPolicy：用调用者所在的线程来执行任务； DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。 ExectorsExectors工厂类提供了线程池的初始化接口，主要有如下几种: newFixedThreadPool初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列，不过当线程池没有可执行任务时，也不会释放线程。1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newCachedThreadPool 初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列； 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销; 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; Java线程池的原理及几类线程池的介绍 深入分析java线程池的实现原理","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"MarkDowm命令","slug":"MarkDowm","date":"2016-12-05T16:00:00.000Z","updated":"2016-12-22T06:21:12.000Z","comments":true,"path":"2016/12/06/MarkDowm/","link":"","permalink":"http://yoursite.com/2016/12/06/MarkDowm/","excerpt":"","text":"基本用法标题1234# 一级标题## 二级标题### 三级标题... 有序列表12341. 列表2. 列表3. 列表... 无序列表123* 列表* 列表* 列表 引用1&gt; 这是一个引用 链接与图片123[baidu](www.baidu.com)![icon](http://ohqvqufyf.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD.jpeg) 字体123*这是斜体***这是粗体** 表格123| 表格1 | 表格2 ||--- |--- || 哈哈 | 呵呵 | code123void helloWorld()&#123; print(\"%s\", \"helloWorld\");&#125; 嵌入音乐，视频 MarkDowm 支持原始的html语法，可以使用html标签插入音乐和视频。 图片HTML代码12&lt;img src=\"http://ohqvqufyf.bkt.clouddn.com/girl.png\" alt=\"girl\"&gt; 效果： 音乐HTML5代码1234&lt;audio controls loop&gt; &lt;source src=\"http://ohqvqufyf.bkt.clouddn.com/%E9%99%88%E4%B8%80%E5%8F%91%E5%84%BF%20-%20%E7%AB%A5%E8%AF%9D%E9%95%87.mp3\" type=\"audio/mpeg\"/&gt; Your browser does not support HTML5 audio.&lt;/audio&gt; 效果: Your browser does not support HTML5 audio. 视频HTML5代码1234&lt;video width=\"320\" controls&gt; &lt;source src=\"http://ohqvqufyf.bkt.clouddn.com/fyq.mp4\" type=\"video/mp4\" /&gt; Your browser does not support HTML5 video. &lt;/video&gt; 效果： Your browser does not support HTML5 video.","categories":[],"tags":[{"name":"MarkDowm","slug":"MarkDowm","permalink":"http://yoursite.com/tags/MarkDowm/"}]},{"title":"二叉树转换成双向链表(day6)","slug":"everydayc/day6","date":"2016-11-19T16:00:00.000Z","updated":"2016-12-22T08:09:13.000Z","comments":true,"path":"2016/11/20/everydayc/day6/","link":"","permalink":"http://yoursite.com/2016/11/20/everydayc/day6/","excerpt":"","text":"题目 题目：输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。要求不能创建任何新的结点，只调整指针的指向。比如将二元查找树 12345678将 10 / \\ 6 14 / \\ / \\ 4 8 12 16 转换成双向链表4=6=8=10=12=14=16 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Node &#123; int value; Node* left; Node* right;&#125;;bool createList(Node* head, Node* &amp;left, Node* &amp;right)&#123; left = head; right = head; if(!head)&#123; return false; &#125; else &#123; Node *l1, *r1, *l2, *r2; l1 = NULL; r1 = NULL; l2 = NULL; r2 = NULL; if(createList(head-&gt;left, l1, r1))&#123; head-&gt;left = r1; r1-&gt;right = head; left = l1; &#125; if(createList(head-&gt;right, l2, r2))&#123; head-&gt;right=l2; l2-&gt;left=head; right = r2; &#125; return true; &#125;&#125;int main()&#123; Node n4=&#123;4,NULL,NULL&#125;; Node n5=&#123;8,NULL,NULL&#125;; Node n6=&#123;12,NULL,NULL&#125;; Node n7=&#123;16, NULL, NULL&#125;; Node n2=&#123;6,&amp;n4,&amp;n5&#125;; Node n3=&#123;14,&amp;n6,&amp;n7&#125;; Node n1=&#123;10,&amp;n2,&amp;n3&#125;; Node*Left=NULL; Node*Right=NULL; createList(&amp;n1,Left,Right); while(Left)&#123; cout&lt;&lt;Left-&gt;value&lt;&lt;endl; Left=Left-&gt;right; &#125; return 0;&#125; 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android Annotation使用","slug":"android/java-annotation","date":"2016-11-09T16:00:00.000Z","updated":"2016-12-21T06:50:48.000Z","comments":true,"path":"2016/11/10/android/java-annotation/","link":"","permalink":"http://yoursite.com/2016/11/10/android/java-annotation/","excerpt":"","text":"要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。 元注解 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： @Target @Retention @Documented @Inherited 这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。 Target @Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 12345678910111213141516171819202122232425262728/** Class, interface (including annotation type), or enum declaration */TYPE,/** Field declaration (includes enum constants) */FIELD,/** Method declaration */METHOD,/** Formal parameter declaration */PARAMETER,/** Constructor declaration */CONSTRUCTOR,/** Local variable declaration */LOCAL_VARIABLE,/** Annotation type declaration */ANNOTATION_TYPE,/** Package declaration */PACKAGE,/** * Type parameter declaration * * @since 1.8 */TYPE_PARAMETER,/** * Use of a type * * @since 1.8 */TYPE_USE 取值(ElementType)有： CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 使用实例: 12345678@Target(ElementType.TYPE)public @interface Table &#123; /** * 数据表名称注解，默认值为类名称 * @return */ public String tableName() default \"className\";&#125; 注解Table 可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。 Retention： @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。M","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Vim-command","slug":"vim-command","date":"2016-11-04T16:00:00.000Z","updated":"2016-12-22T08:15:49.000Z","comments":true,"path":"2016/11/05/vim-command/","link":"","permalink":"http://yoursite.com/2016/11/05/vim-command/","excerpt":"","text":"光标移动 命令 作用 h,j,k,l 左 下 右 上 Ctrl+f 上一页 Ctrl+b 下一页 w,e,W,E 调到单词后面，小写包括标点 O 开启新的一行 ^ 一行的开始 gg 文档的结尾 [N]G 文档的第N行或者最后一行 插入模式 命令 作用 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 编辑 命令 作用 r 在插入模式替换光标所在的一个字符 J 合并下一行到上一行 s 删除光标所在的一个字符，光标还在当行 S 删除光标所在的一行, 光标还在当行，不同于dd u 撤销上一步操作 ctrl+r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 [N]&gt;&gt; 一行或N行往右移动一个tab [N]&lt;&lt; 一行或N行往左移动一个tab 关闭 命令 作用 :q 保存 :wq, :x 保存并关闭 :q 关闭 :q! 强制关闭 搜索 命令 作用 /pattern 搜索(非插入模式) ?pattern 向后搜索 n 光标到达搜索结果的前一个目标 N 光标到达搜索结果的后一个目标 视觉模式 命令 模式 v 选中一个或多个字符 V 选中一行 剪切和复制 命令 作用 dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 窗口命令 命令 作用 : split 水平分割出一个窗口 :vsplit 垂直分割出一个窗口 :close 关闭窗口 ctrl+w 切换窗口 h,j,k,l 左下上右","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}]},{"title":"字符串剔除(day5)","slug":"everydayc/day5","date":"2016-10-23T16:00:00.000Z","updated":"2016-12-22T08:18:51.000Z","comments":true,"path":"2016/10/24/everydayc/day5/","link":"","permalink":"http://yoursite.com/2016/10/24/everydayc/day5/","excerpt":"","text":"题目 输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入”They are students.”和”aeiou”，则删除之后的第一个字符串变成”Thy r stdnts.”。 思路最简单的。设source长n，key长m(n&gt;&gt;m)，则使用简单的遍历查找需要n*m次(n个字符，查找m次)，且每次删除对应元素需要O(1)时间(元素移动)。时间复杂度为O(n.^2); 以下思路。查找时间复杂度为O(n),删除时间复杂度为O(n)。即O(n)的时间内完成。 建立长度为256(char元素总数)的hash数组(类似基排序)，遍历key。即需要在source中删除的字符在hashtable上不为0。复杂度O(m)。 设定指针 temp和needDelete，初始化指向source. temp用来遍历source，任何时候指向不需要删除的字符。needDelete指向当前需要删除的第一个字符。 使用间接删除法。即将temp的值赋给source。 任何一轮循环。needDelete–temp-1的字符都可以被删除(即替代)。temp之前不需要删除的字符，都已经挪到needDelete之前。 以temp为空位结束条件。最后给needDelete赋空。 整体思路,从第一个删除的位置开始，依次把后面不需要删除的字符向前赋值。 1234567891011121314151617181920212223char *deleteStr(char *source, const char *key) &#123; if (!source || !key) return NULL; const char *temp = key; //static int hashTable[256]; int *hashTable = new int[256]; memset(hashTable, 0, 256 * sizeof(int)); while (*temp) hashTable[*temp++]++; temp = source; char *needDelete = source; while (*temp) &#123; if (!hashTable[*temp]) &#123;//不需要删除的字符，前移赋值 *needDelete = *temp; needDelete++; &#125; temp++; &#125; *needDelete = '\\0'; delete[]hashTable; return source;&#125; 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android面试题整理","slug":"android/Android面试题整理","date":"2016-10-21T16:00:00.000Z","updated":"2017-02-09T14:47:30.000Z","comments":true,"path":"2016/10/22/android/Android面试题整理/","link":"","permalink":"http://yoursite.com/2016/10/22/android/Android面试题整理/","excerpt":"","text":"Java GC是什么?为什么要有GC? GC是垃圾收集的意思(Garbage Collection), 内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动的检测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 XML包括哪些解析技术，区别是什么？ DOM和SAX DOM将文档解析成一颗文档树，可在节点上进行遍历、增加、修改和删除。一次性读入内存，对内存消耗大。 SAX至上而下解析文档，以事件进行驱动。不会一次性读入内存，对内存消耗小，不能任意读取节点，并且不能对节点进行增加、修改和删除。 switch语句能否作用在byte上，能否作用在long上，能否作用在String上? switch 能作用在byte, short. char,int, 在JDK1.7以后可以作用在String上。 “==”和equals方法究竟有什么区别？ ==和equals都可以比较地址, ==是运算符，equals是方法，方法可以通过重写改变其行为，如String的equals就是比较字符串内容。 构造方法能否被重写和重载？ 不能被重写，但能被重载。 面向对象的特征有哪些？ 封装，继承，多态，抽象 抽象类和接口的区别？ 抽象类是abstract class 修饰符，接口是interface修饰符。 抽象类可以有任意属性， 接口只能有静态常量修饰的属性。 抽象类可以有普通方法和抽象方法，接口只能有抽象方法。 抽象类和接口都不能实例化，但是抽象类有构造方法，接口没有。5. 抽象类只能单继承，接口可以多继承。 内部类可以引用它的包含类的成员吗？有没有什么限制？ 可以引用， 如果需要制定当前类时要用到外部类.this。如果引用局部变量，需要将局部变量指定为final。 String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？ 创建了2个对象， “xyz” 创建在常量池中， new String() 创建在堆中 try {}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后? 会执行，在return之前 Integer与int的区别 Integer为包装类， int 是基本数据类型。包装类拥有方法和属性，基本数据类型不具备。包装类可以通过intValue来转换基本数据类型,也可以通过new Integer()将基本数据类型转换为包装类。在JDK1.5后，包装类和基本数据类型可以实现自动转换。 sleep()和wait()有什么区别? sleep是Thread类的方法，wait是Object类的方法。sleep是自动唤醒，wait需要其他线程来唤醒。sleep不会释放同步锁，wait会释放同步锁。sleep可以用在任意方法中，wait只能在同步方法或同步块中。sleep()不会释放对象锁到时自动恢复,wait()会释放对象锁进入等待此对象的锁定池发出notify()方法后才进入锁定池。 同步和异步有何异同，在什么情况下分别使用他们？ 同步指同一时间只能一个线程执行该方法，其他线程需要等待。异步指多个线程可以同时执行某个方法，并共享同一资源。同步可以让访问的资源具有安全性，同一时间只能一个线程对其访问。但效率不高。异步对访问的资源会造成不稳定性，比如多个线程同时访问一个资源，一个在修改，一个在删除，一个在读取，这样可能会造成资源的混乱。但是效率提高。 启动一个线程是用run()还是start()? statr()启动线程, run()方法是线程执行的主方法。 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ java中有三种流，分别是字节流(InputStream, OutputStream), 字符流(Reader,Writer), 对象流(ObjectInputStream, ObjectOutputStream) 字节流和字符流的区别？ 字节流用于读取或写出二进制数据，比如图片，影响等数据。字符流用于读取或写出字符数据，比如传输字符串。所有的数据都可以通过字节流来处理，如果是字符数据，用字节流还需要进行转换后传输，如果使用字符流可以方便数据的转换。 error和exception有什么区别？ error 是系统错误，代码不能处理的错误，比如内存溢出，堆栈溢出等。exception是程序异常，可以通过try-cache进行处理，如空指针，数组越界等。 谈谈final，fianlly, finalize的区别？ final 是修饰符，可以修饰类(不能被继承)，属性(常量)和方法(不能被重写)finally是异常处理块的代码块，表示无论如何都会执行的代码块。finalize是Object类方法,该方法在对象被垃圾回收之前执行的方法。 当一个线程进入一个对象的synchronized方法后，其他线程是否可以进入此方法的其他方法？ 如果其他方法没有设置synchronized是可以进入的。 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? java中只有值传递，如果传递的对象，实际也是传递该对象的地址。 作用域public,private,protected,以及不写时的区别 public公共修饰符，所有的类都可以访问protected为受保护的修饰符，表示同类、同包以及不同包但是父子关系的是可以访问。不写表示默认修饰符,或者称为package修饰符，该修饰符表示只有同类huo或同包下的类可以访问，出了这个包就不能访问。private为私有修饰符，表示只有在同类中可以访问，chu’l出了这个类就不能访问。 用最有效率的方法算出2*8 将2左移3位, 2 &lt;&lt; 3 heap和stack有什么区别。 heap表示堆， stack表示栈， 堆中存放对象，栈中存放引用变量堆是无序的空间， 栈是先进后出的结构。 运行时异常与一般异常有何异 运行时异常指继承于RuntimeException的异常，这些异常在编译时可以不进行处理，当运行时如果出现问题才会抛出。如NullPointException, ArrayIndexOutBoundsExceptions一般异常也称为编译时异常，这些异常是继承Exception但又不属于RuntiomException的子类，如果程序出现这些异常，在编译时必须进行捕获或抛出，否则编译无法通过，如IOException, FileNotException 垃圾回收的优点和原理。并考虑2中回收机制。 Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存 管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用 的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能 实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 描述一下JVM加载class原理机制？ JVM中类的装载是由ClassLoader和他的子类来实现的，Java ClassLoader是一个重要的Java运行时系统组件。他负责在运行时查找和装入类文件的类。 是否可以从一个static方法内部发出非static方法的调用？ 不能，除非先创建非static方法所在类的对象。 什么是java序列化，如何实现java序列化？ 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序 列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化 的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的 writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。 Anonymous Inner Class(匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)？ 匿名内部类可以继承类或实现接口，但不是显示的使用extends或implements来继承或实现。 ArrayList和Vector的区别,HashMap和Hashtable的区别？ ArrayList是JDK1.2的集合类型线程不安全，Vector是1.0的集合并且线程安全，二者用法相似。HashMap线程不安全且能放空键或空值，HashTable线程安全且不能放空键或空值。 String 和StringBuffer有什么差别？在什么情况下使用它们？ String 是字符串的基本类，该字符串是不可变的。StringBuffer是利用堆来存储字符串，并且可以对字符串的内容进行改变。 new一个类对象和使用类名创建一个对象有什么区别？二者使用时应该注意什么？ new对象是最常见的创建对象的方式。利用模板通过反射来创建对象。虽然new对象时在底层也会通过类模板来创建对象，但是new对象的效率要比直接通过类模板创建对象的方式要高。但是使用类模板的方式可以让程序的灵活性提高。 LinkedList和ArrayList的区别？ LinkedList是链表结构的集合，ArrayList是数组结构的集合。LinkedList在中间或前面增加或删除数据时效率要比ArrayList高。LinkedList在最后添加或删除数据时比ArrayList低遍历数据时ArrayList效率高于LinkedList 介绍JAVA开发中常用的Collection FrameWork（集合框架）? Java中集合框架分为Collection和Map接口，Collection接口下的集合每个元素都是由一个值组成，Map接口下的集合类每个元素都是由键值对组成。Collection接口下面有List和Set接口，List接口下常见的类有ArrayList, LinkerList,Vector。 他们中的元素可以重复，并且是有序的。Set接口常见的类HashSet, TreeSet。他们中的元素不能重复，并且是无序的。 在异常当中 throw和throws 有什么区别和联系？ throw是在代码中抛出一个异常，后面跟的是异常对象，虚拟机运行到这里时会立即引发一个异常。throws是写在方法声明上的，表示声明该方法可能会抛出异常，后面跟的是异常类型。调用该方法的时候可以选择处理它或继续往外抛。 重载和重写的区别 重载是指一个类中，两个或两个以上的方法具有相同的方法名和不同的参数列表，则表示这些方法为重载方法。重写是指父类和子类中，子类方法和父类方法具有相同的方法名，相同参数，相同返回类型，子类的访问修饰符范围不小于父类的访问修饰符范围，异常的类型个个数不大于或多于父类的异常类型和个数，则表示该方法为重写方法。换句话说重载方法是区分同一个类中相同方法名的方法，重写方法是找到父类相同方法名的方法并重写改变方法的行为。 Java中try catch finally的执行顺序 try -&gt; 发生异常执行catch -&gt; 最后一定会执行finall 内存泄露的原因： 资源对象没关闭。 如Cursor, File等资源。他们会在finalize中关闭,但这样效率太低。容易造成内存泄露。SQLiteCursor,当数据量大的时候容易泄露。 使用Adapetr时， 没有使用系统缓存的converView. 即时调用recycle()释放不再使用的Bitmap。 适当降低Bitmap的采样率，如：12345BitmapFactory.Option option = new BitmapFactory.Options();options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一。Bimap bitmap = BitmapFactory.decodeStream(cr.openInputStream(uri), null, options);preview.setImageBitmap(bitmap); 使用application的context来代替activity相关的context。 注册没取消造成内存泄露。 如：广播 集合中的对象没清理造成的内存泄露我们通常把一些对象的引用加入到了集合中，当我们不需要gai该对象时，并没有把它的应用从集合中清理掉，这样这个集合就会越来越大。如果这个集合static的话，那情况就更加严重。 Handle应当声明为静态对象，并在内部类中保存一个对外部类的弱引用。如:12345678910111213static class MyHandler extends Handler &#123; WeakRefrence&lt;Activity&gt; mActivityRefrence; MyHandler(Activity activity) &#123; mActivityRefrence = new WeakRefrence&lt;Activity&gt;(activity); &#125; @Override public void handlerMessage(Message msg) &#123; final Activity activity = mActivityRefrence.get(); if(activity != null)&#123; mImageView.setImageBitmap((Bitmap)(msg.getObj1())); &#125; &#125;&#125; Iterator和Enumeration的不同 函数接口不同Enumeration只有2个函数接口。通过Enumeration,我盟只能读取集合的数据，而不能对数据进行修改。Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。 Iterator支持fail-fast机制，而Enumeration不支持。 Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类 都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现 Enumeration时，添加了同步。而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast 机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。ail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线 程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异 常，产生fail-fast事件。 接口的注意点 接口的字段全部默认为public static 类型。 接口中的方法全部默认为public类型。 接口中可以声明内部类，而默认为public static,正因为是static,只是命名空间属于接口，代码逻辑不属于接口。所有不违反接口定义。 接口本省可以声明为pullic 或者缺省。 抽象类继承某接口。如果在抽象类中实习了父类(接口)中的方法，在其子类可以不用实现，否则在子类必须实现。 final方法 将方法声明为final那有两个原因，第一就是说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。第二就是允许编译器将所有对此方法的调用转化为inline调用的机制，它会使你在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，所以你要慎用final进行方法定义。 Android Activity, Service, BroadcastReceiver的作用 Activity: Activity 是Android程序与用户交互接窗口，是Android构造块中最基本的一种，他需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑。 Service: 后台服务于Activity, 封装有一个完整的功能逻辑实现，接受上层命令，完成相关的指令，定义好需要接受Intent提供同步和异步的接口 BroadcastReceiver: 接受一种或者多种Intent做触发事件，接受相关消息，做一些简单处理，转换成一条Notification,统一了Android的事件广播模型。 Activity 生命周期 onCreate(), onStart(), onResume(), onPause(), onReStart(), onStop(), onDestory() 显示Intent和隐式Intent的区别是什么？ Intent定义: Intent是一种在不同组件之间传递的请求消息，是程序发出的请求和意图，作为一个完整的消息传递机制，Intent不仅需要发送端，还需要接收端。显示Intent定义: 对明确指出了目标组件名称Intent,我们称之为显示Intent。隐式Intent定义: 对于没有明确指出目标组件名称Intent,则称之为隐式Intent.说明: Android系统使用IntentFilter 来寻找与隐式Intent相关的对象。 Android 线程同步的方法 线程同步的方法可以采用同步方法和同步块。 怎么讲一个Activity封装成对话框的样子？怎样将Activity封装成按Menu菜单的样子。 简单你只需要设置一下Activity的主题在Android Manifest.xml中定义Activity的地方一句话： 1234//设置为DialogActivityandroid:theme=\"@android:style/Theme.Dialog\"//设置背景为半透明android:theme=\"@android:style/Theme.Translucent\" 重写OnCreateOptionMenu方法来处理按下menu后的行为，然后再该方法中弹出对话框形式的Activity.也可以利用时间监听来监听menu按键，并在该按钮按下后弹出对话框形式的Activity. 介绍Android体系结构 Android分为4层应用层： Android的应用程序与的用户交互界面。应用框架层： UI组件， 管理器， 工具类。函数库层：系统C库，媒体库，Webkit, SQLite等。Linux核心库： linux系统运行的组件。 描述下横竖屏切换时候 activity 的生命周期 123456//不设置, 切屏会重新调用生命周期，横屏时会执行一次，切竖屏会执行两次。android:configChanges//切屏还是会重新调用各个生命周期，切横，竖屏时只会执行一次。android:configChanges=\"orientation\"//切屏不会重新调用各个生命周期，只会执行onConfiguraationChanged方法android:configChanges=\"orientation|keyboardHidden\" android 中的动画有哪几种，它们的特点和区别是什么 ? 帧动画(Frame)和补间动画(Tween),Tween动画，这种实现方式可以是试图组件移动，放大，缩小以及产生透明度的变化；另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片实现，类似电影。 一条短信多少个byte? 140byte, 70个汉字 handle机制 Handle的作用，发送消息到消息队列，接受Looper传递的消息。主线程启动时会调用Looper.prepare()方法，初始化一个Looper,放入TreadLocal中，接着调用Looper.loop()不断遍历Message Queue. Handler的创建依赖与当期线程中的Looper,如果当前线程没有Looper则必须调用Looper.perpare()。Handler的创建依赖与当前线程中的Looper，如果当前线程没有Looper则必须调用Looper.prepare()。Handler , sendMessage到MessageQueue，Looper不断从MessageQueue中取出消息，回调handleMessage方法。 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布 ? 可以将dictionary.db文件复制到Eclipse Android工程中的res\\raw目录中。所有在res\\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。使用openDatabase方法来打开数据库文件，如果该文件不存在，系统会自动创建/sdcard/dictionary目录，并将res\\raw目录中的 dictionary.db文件复制到/sdcard/dictionary目录中 说说 android 中 mvc 的具体体现 mvc 是model,view,controller的缩写 模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。 视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。Android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下： view: 一般采用xml文件进行界面的描述。 controller: Android的控制层通常落在Activity中。 model: 数据库操作，网络请求都应该在model中处理。 请介绍下 Android 中常用的五种布局 FrameLayout RelativeLayout LinearLayout TableLayout AbsoluteLayout 如何启用 Service ，如何停用 Service StartService() 启动服务， StopService(); bindService, unBindService 如何优化ListView contentView的复用 如果item过多时，考虑分页加载 描述4种 activity 的启动模式 standard: 系统的默认模式， 一次跳转即会生成一个新的实例2，singTop: 如果要启动的Activity已经在回退栈的顶部时， 不会生成新的实例。 singTask: 如果要启动的Activity在回退栈中的时候，此Activity之上的所有Activity释放，直到栈顶是要启动的Activity. singInstance: 启动Activity时同时创建一个新的栈并在新栈中创建这个Activity实例。 什么是Intent，如何使用？ Android设计理念是鼓励减少组件之间的耦合，因此Android提供了Intent(意图)， Intent提供一种通用的消息系统，他允许在你的应用程序与其他的应用程序间传递Intent来执行动作和产生事件。使用Intent可以激活Android应用的三个核心组件： 活动，服务和广播接受器。通过startActivity() or startActivityForResult()启动一个Activity；startService()启动一个服务，或者通过bindService()广播(sendBroadcast(), sendOrderedBroadcast(), sendStickyBroadcast())发给broadcastReceivers Android用的数据库是什么样的？它和Sql有什么区别？为什么要用ContentProvide? 它和SQL的实现有什么差别？ android用的是SQLite数据库。它和其他网络数据库类似，也是通过SQL对数据进行管理。SQLite的操作非常简单，包括数据类型在建表时也可以不指定。使用ContentProvider 可以将数据共享给其他应用，让除本应用之外的应用也可以访问本应用的数据。它的底层是用SQLite 数据库实现的，所以其对数据做的各种操作都是以Sql实现，只是在上层提供的是Uri。 通过Intent传递一些二进制数据的方法有哪些？ Serializable序列化 Parcelable接口，Android的部分类比如Bitmap类就已经实现，同时Parcelable在Android AIDL中交换数据也很常见。 对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行？ onResume()中恢复数据， onPause()保存数据。 如何一次性退出所有打开的Activity 编写一个Activity作为入口，当需要关闭程序时，可以利用Activity的singTask模式跳转该Activity,它上面所有的Activity都会被销毁，或者在Intent设置Flag 12345678910//A B C D ----&gt; D start B -----&gt; A BIntent intent = new Intent(this, B.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);startActivity(intent);//A B C D ----&gt; D start B ------&gt; A C D BIntent intent = new Intent(this, MainActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);startActivity(intent); Service生命周期？ 启动Service的方式有两种，各自的生命周期也有不同。 通过statrService启动Service: onCreate, onStartCommand, onDestory 通过bindServcie启动Service: onCreate, onBind, onUnBind, onDestory 什么是AIDL？AIDL是如何工作的？ AIDL(Android Interface definition language), 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的，如果需要在一个Activity中，访问另一个Service中的某个对象，需要先将对象转化成AIDL可识别的参数(可能是多个参数)，然后使用AIDL来传递这些参数，在消息的接受端，使用这些参数组装成浙江需要的对象， AIDL是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值。 Android如何把文件存放在SDCard上？ 在AndroidManifest.xml中添加权限 1234&lt;!- 在SDCard中创建与删除文件权限 -&gt;&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/&gt;&lt;!- 往SDCard中写入的权限 -&gt;&lt;uses-permission Android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; 要往SDCard存放文件，程序必须先判断手机是否装有SDCard,并且可以进行读写。注意：访问SDCard必须在AndroidManifest.xml中加入访问SDCard的权限。Environment.getExternalStorageState()方法用于获取SDCard的状态，如果手机装有SDCard，并且可以进行读写，那么方法返回的状态等于Environment.MEDIA_MOUNTED。Environment.getExternalStorageDirectory()方法用于获取SDCard的目录。 注册广播有几种方式，这些方式有何优缺点？ 两种。 一种是通过代码注册，这种方式注册的广播会跟随程序的生命周期。第二是在AndroidManifest.xml中注册，这种常驻型广播当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 什么是ANR 如何避免它? 在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR）对话框。用户可以选择让程序继续运行，但是他们在使用你的应用程序并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。要避免它，应该尽量少在主线程做耗时太长的操作，应该将这些操作放在线程当中去做。 Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决? 有可能，比如空指针异常、数组下表越界等异常，这些异常抛出后可能会导致程序FC。在编写代码时应该做好检测，多考虑可能会发生错误的情况，从代码层次解决这些问题。 为什么要用 ContentProvider?它和 sql 的实现上有什么差别? 使用ContentProvider 可以将数据共享给其他应用，让除本应用之外的应用也可以访问本应用的数据。它的底层是用SQLite 数据库实现的，所以其对数据做的各种操作都是以Sql实现，只是在上层提供的是Uri。 谈谈 UI 中, Padding 和 Margin 有什么区别? padding指内边距，表示组件内部元素距离组件边框的距离。marin指外边距，表示组件与组件之间的距离。 请介绍下 Android 的数据存储方式。 使用SharedPreferences存储数据; 文件存储数据； SQLite数据库存储数据； 使用ContentProvider存储数据； 网络存储数据； Android的LPC机制四大组件都可以设置为多进程模式，设置process属性，多进程会导致单例失效，存储失效，有效的多进程之间的访问可以使用AILD， sockct, ContentProvider等。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"GreenDao使用详解","slug":"GreenDao使用基础","date":"2016-10-19T16:00:00.000Z","updated":"2016-12-19T08:03:30.000Z","comments":true,"path":"2016/10/20/GreenDao使用基础/","link":"","permalink":"http://yoursite.com/2016/10/20/GreenDao使用基础/","excerpt":"","text":"介绍官网地址 GreenDao github GreenDao 优点 性能高，号称Android最快的关系型数据库 内存占用小 库文件比较小，小于100K，编译时间低，而且可以避免65K方法限制 支持数据库加密 greendao支持SQLCipher进行数据库加密 有关SQLCipher可以参考这篇博客Android数据存储之Sqlite采用SQLCipher数据库加密实战 简洁易用的API GreenDao 3.0基本使用在.gradle添加依赖1234567891011121314buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' &#125;&#125;apply plugin: 'org.greenrobot.greendao'dependencies &#123; compile 'org.greenrobot:greendao:3.2.0'&#125; 需要配置数据库的基本属性 1234greendao &#123; schemaVersion 1 targetGenDir 'src/main/java'&#125; schemaVersion：数据库版本号 daoPackage：设置DaoMaster, DaoSession, Dao包名 targetGenDir: 设置DaoMaster, DaoSession, Dao目录 targetGenDirTest: 设置生成单元测试目录 generateTests 设置自动生成单元测试用例 创建实体123456789@Entity()public class User &#123; @Id private Long id; private String name; private int age; //省去了get/set方法&#125; 实体@Entity注解: schema：表示GreenDao当前实体属于哪个schema active: 标记一个实体处于活动状态，活动实体有更新，删除和刷新方法 nameInDb: 在数据中使用的别名，默认使用的是实名的类别 indexes: 定义索引，可以跨越多个列 createInDb: 标记创建数据库表 基础属性注解: @Id: 主键 Long型，可以通过@Id(autoincrement = true)设置自增长 @Property: 设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=”name”) @NotNul：设置数据库表当前列不能为空 @Transient ：添加次标记之后不会生成数据库表的列 索引注解: @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束 @Unique：向数据库列添加了一个唯一的约束 关系注解: @ToOne：定义与另一个实体（一个实体对象）的关系 @ToMany：定义与多个实体对象的关系 编译生成DaoMaster, DaoSession, Dao 创建一个数据库管理者单例 12345678910111213141516171819202122232425262728public class DBManager &#123; private final static String dbName = \"test_db\"; private static DBManager mInstance; private DaoMaster.DevOpenHelper openHelper; private Context context; public DBManager(Context context) &#123; this.context = context; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); &#125; /** * 获取单例引用 * * @param context * @return */ public static DBManager getInstance(Context context) &#123; if (mInstance == null) &#123; synchronized (DBManager.class) &#123; if (mInstance == null) &#123; mInstance = new DBManager(context); &#125; &#125; &#125; return mInstance; &#125;&#125; 获取可读可写数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 获取可读数据库 */private SQLiteDatabase getReadableDatabase() &#123; if (openHelper == null) &#123; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); &#125; return openHelper.getReadableDatabase();&#125;/** * 获取可写数据库 */private SQLiteDatabase getWritableDatabase() &#123; if (openHelper == null) &#123; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); &#125; return openHelper.getWritableDatabase();&#125;/** * 插入一条记录 * * @param user */public void insertUser(User user) &#123; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.insert(user);&#125;/** * 插入用户集合 * * @param users */public void insertUserList(List&lt;User&gt; users) &#123; if (users == null || users.isEmpty()) &#123; return; &#125; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.insertInTx(users);&#125;/** * 删除一条记录 * * @param user */public void deleteUser(User user) &#123; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.delete(user);&#125;/** * 更新一条记录 * * @param user */public void updateUser(User user) &#123; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.update(user);&#125;/** * 查询用户列表 */public List&lt;User&gt; queryUserList() &#123; DaoMaster daoMaster = new DaoMaster(getReadableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); QueryBuilder&lt;User&gt; qb = userDao.queryBuilder(); return qb.list();&#125;/** * 查询用户列表 */public List&lt;User&gt; queryUserList(int age) &#123; DaoMaster daoMaster = new DaoMaster(getReadableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); QueryBuilder&lt;User&gt; qb = userDao.queryBuilder(); qb.where(UserDao.Properties.Age.gt(age)).orderAsc(UserDao.Properties.Age); return qb.list();&#125; 外键使用(@ToOne, @ToMany)123456789101112131415@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; @NotNull private String name; private int age; private Long blogId; @ToOne(joinProperty = \"blogId\") private Blog blog;&#125; joinProperties这个参数是referencedJoinProperty 参数的升级版。在referencedJoinProperty参数中我们发现俩个实体关联的外键是CustomerId与id，但是如果我们的需求是外键不能通过id来定义，需要用自己自定义属性来定义，第一种方法就没法用了，而joinProperties就是为了解决这个需求的。 github源码 参考资料GreenDao 3.0使用 Android数据存储之GreenDao 3.0 详解 GreenDao3.0新特性解析（配置、注解、加密 史上最高效的ORM方案——GreenDao3.0高级用法","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"移位查找（day4）","slug":"everydayc/day4","date":"2016-10-17T16:00:00.000Z","updated":"2016-12-22T08:16:38.000Z","comments":true,"path":"2016/10/18/everydayc/day4/","link":"","permalink":"http://yoursite.com/2016/10/18/everydayc/day4/","excerpt":"","text":"题目 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 思路 全部元素异或，结果一定不为0，且结果为只出现1次的元素的异或。 以第结果的第一个非0位(假设第N位)来看，所有元素在该位置的0,1都出现了奇数次。 以N为基准，为0的分为一组，为1的分为一组。则这两个数分别分到2组。 这两组分别异或，结果即为所求。 12345678910111213141516171819//函数功能 ： 找出数组中两个只出现一次的数字//函数参数 ： arr为源数组，len为数组元素个数，result用来存放结果void function1(int *arr, int len, int *result) &#123; int i, all = 0, flag = 1; for (int i = 0; i &lt; len; ++i) &#123; //所有数异或 all ^= arr[i]; &#125; while (!all &amp; flag) &#123; flag &lt;&lt;= 1; &#125; result[0] = result[1] = 0; //利用过滤位区分 for (i = 0; i &lt; len; i++) &#123; if (flag &amp; arr[i]) result[0] ^= arr[i]; else result[1] ^= arr[i]; &#125;&#125; 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"链表删除(day3)","slug":"everydayc/day3","date":"2016-10-05T16:00:00.000Z","updated":"2016-12-22T08:18:02.000Z","comments":true,"path":"2016/10/06/everydayc/day3/","link":"","permalink":"http://yoursite.com/2016/10/06/everydayc/day3/","excerpt":"","text":"假设链表……—A–B–C–D….，要删除B。一般的做法是遍历链表并记录前驱节点，修改指针，时间为O(n)。删除节点的实质为更改后驱指针指向。 这里，复制C的内容至B(此时B，C同时指向D)，删除节点C，即达到间接删除节点B的目的。 倘若B是链尾节点。则需要线性遍历寻找前驱节点。以上思路，时间复杂度为O(1)。123456789101112131415161718192021222324252627282930struct ListNode &#123; int m_nKey; ListNode *m_pNext;&#125;;void deleteNode(ListNode* pListHead, ListNode* pToBeDeleted) &#123; if (!pListHead || !pToBeDeleted) &#123; return; &#125; if (pListHead == pToBeDeleted)&#123; delete pListHead; pListHead = NULL; pToBeDeleted = NULL; &#125; else if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; ListNode* pNode = pListHead; while(pNode-&gt;m_pNext != pToBeDeleted) &#123; pNode = pNode-&gt;m_pNext; &#125; pNode-&gt;m_pNext = NULL; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125; 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"位运算计数(day2)","slug":"everydayc/day2","date":"2016-09-19T16:00:00.000Z","updated":"2016-12-22T08:15:29.000Z","comments":true,"path":"2016/09/20/everydayc/day2/","link":"","permalink":"http://yoursite.com/2016/09/20/everydayc/day2/","excerpt":"","text":"题目: 求整数的2进制表示中1的个数整数 右移 相与123456789int function1(int i) &#123; int count = 0; while(i) &#123; if(i &amp; 1) count ++; i = i &gt;&gt; 1; &#125; return count;&#125; flag 左移 相与1234567891011int function2(int i) &#123; int count = 0; unsigned int flag = 1; while(flag)&#123; if(i &amp; flag)&#123; count ++; &#125; flag = flag &lt;&lt; 1; &#125; return count;&#125; 减一相与12345678int function3(int i) &#123; int count = 0; while (i) &#123; ++ count; i = (i - 1) &amp; i; &#125; return count;&#125; 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"递归加法(day1)","slug":"everydayc/day1","date":"2016-08-05T16:00:00.000Z","updated":"2016-12-22T08:15:24.000Z","comments":true,"path":"2016/08/06/everydayc/day1/","link":"","permalink":"http://yoursite.com/2016/08/06/everydayc/day1/","excerpt":"","text":"题目：求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C).使用函数指针1234567891011121314151617//-----&gt;fun1 start//使用函数指针 递归加法typedef int (*fun)(int);int func1(int n) &#123; return 0;&#125;int func2(int n) &#123; fun f[2] = &#123;func1, func2&#125;; return n + f[(n != 0)](n - 1);&#125;void function1() &#123; cout &lt;&lt; func2(10) &lt;&lt; endl;&#125;//-----&gt;fun2 end 使用静态变量1234567891011121314151617181920212223242526272829//-----&gt;fun2 start//使用静态变量class test &#123; static int N; static int sum;public : test() &#123; sum += ++N; &#125; static void reset() &#123; N = sum = 0; &#125; static int getSum() &#123; return sum; &#125;&#125;;int test::N = 0;int test::sum = 0;void function2() &#123; test::reset(); test *p = new test[10]; cout &lt;&lt; test::getSum() &lt;&lt; endl; delete[]p;&#125;//---&gt;fun2 end 使用虚函数的编译多态性123456789101112131415161718192021222324//-----&gt;fun3 start//使用虚函数的编译多态性class A &#123;public: virtual int sum(int n) &#123; return 0; &#125;;&#125;;class B : public A &#123;public: int sum(int n) &#123; A a; B b; A *p[2] = &#123;&amp;a, &amp;b&#125;; return n + p[(n - 1 != 0)]-&gt;sum(n - 1); &#125;&#125;;void function3() &#123; B b; cout &lt;&lt; b.sum(10) &lt;&lt; endl;&#125;//-----&gt;fun3 end 源码github","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"GitHub不允许上传大于100M文件问题","slug":"github上传问题","date":"2016-05-19T16:00:00.000Z","updated":"2017-01-09T03:34:52.000Z","comments":true,"path":"2016/05/20/github上传问题/","link":"","permalink":"http://yoursite.com/2016/05/20/github上传问题/","excerpt":"","text":"问题123456自己的项目的版本控制用的是Git，代码仓库在github托管。项目里用到了百度导航SDK，由于百度导航SDK有了新版本，于是就更新到了新版本，更新好了之后想把代码push到github上，结果出错了，被拒绝，具体信息是：Total 3007 (delta 664), reused 0 (delta 0)remote: error: GH001: Large files detected.remote: error: Trace: 7b7de6b9372ee392e0f3961b05ea6f33remote: error: See http://git.io/iEPt8g for more information.remote: error: File XXX/XXX/BaiduNaviSDK/libbaiduNaviSDK.a is 102.68 MB; this exceeds GitHub&apos;s file size limit of 100.00 MBTo https://github.com/XXX/XXXX.git。意思是有大文件，更多信息可到http://git.io/iEPt8g查看，文件libbaiduNaviSDK.a的大小超过了GitHub限制的100M大小。想要push，必须把这个文件移除，可是要怎么移除呢？ 解决方案第一种解决方案123456如果这个文件是最近一次commit的，并且你还没有push到github，那么第一步输入命令 cd /Users/Dora/Desktop/XXX（cd后面的这个路径要换成你自己项目的路径），然后第二步输入命令 git rm --cached /Users/Dora/Desktop/XXX/XXX/libbaiduNaviSDK.a（加下划线部分是你自己的要移除的文件的路径），第三步输入命令 git commit --amend -CHEAD，执行完这步后，这个大文件将会从你的commit记录里移除，并且以后commit都将不会再把它commit了，这时候就可以git push把本地代码push到github上了。 第二种解决方案用到一个叫BFG的工具。我们要到[https://rtyley.github.io/bfg-repo-cleaner/#download]这个网站去下载并学习如何使用这个工具123456789我们要cd进BFG文件所在目录，第一步输入命令java -jar bfg.jar --no-blob-protection --strip-blobs-bigger-than 50M my-repo.git（红色部分是你下载下来的文件的名字,蓝色部分是你需要移除的文件大小，橙色部分是你自己.git文件的路径），第二步cd my-repo.git ，第三步 git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive，第四步 git push，到此大功告成。你的commit历史里所有大于50M的文件的commit全部被清除，这样你就可以push到github上了。这里只是记录了怎么处理遇到的问题，如果想要知道原理，则需要好好好去学习学习。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]}]}