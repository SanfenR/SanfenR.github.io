[{"title":"二叉树转换成双向链表(day5)","date":"2016-12-19T16:00:00.000Z","path":"2016/12/20/everydayc/day6/","text":"题目 题目：输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。要求不能创建任何新的结点，只调整指针的指向。比如将二元查找树 12345678将 10 / \\ 6 14 / \\ / \\ 4 8 12 16 转换成双向链表4=6=8=10=12=14=16 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Node &#123; int value; Node* left; Node* right;&#125;;bool createList(Node* head, Node* &amp;left, Node* &amp;right)&#123; left = head; right = head; if(!head)&#123; return false; &#125; else &#123; Node *l1, *r1, *l2, *r2; l1 = NULL; r1 = NULL; l2 = NULL; r2 = NULL; if(createList(head-&gt;left, l1, r1))&#123; head-&gt;left = r1; r1-&gt;right = head; left = l1; &#125; if(createList(head-&gt;right, l2, r2))&#123; head-&gt;right=l2; l2-&gt;left=head; right = r2; &#125; return true; &#125;&#125;int main()&#123; Node n4=&#123;4,NULL,NULL&#125;; Node n5=&#123;8,NULL,NULL&#125;; Node n6=&#123;12,NULL,NULL&#125;; Node n7=&#123;16, NULL, NULL&#125;; Node n2=&#123;6,&amp;n4,&amp;n5&#125;; Node n3=&#123;14,&amp;n6,&amp;n7&#125;; Node n1=&#123;10,&amp;n2,&amp;n3&#125;; Node*Left=NULL; Node*Right=NULL; createList(&amp;n1,Left,Right); while(Left)&#123; cout&lt;&lt;Left-&gt;value&lt;&lt;endl; Left=Left-&gt;right; &#125; return 0;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"字符串剔除(day5)","date":"2016-12-18T16:00:00.000Z","path":"2016/12/19/everydayc/day5/","text":"题目 输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入”They are students.”和”aeiou”，则删除之后的第一个字符串变成”Thy r stdnts.”。 思路最简单的。设source长n，key长m(n&gt;&gt;m)，则使用简单的遍历查找需要n*m次(n个字符，查找m次)，且每次删除对应元素需要O(1)时间(元素移动)。时间复杂度为O(n.^2); 以下思路。查找时间复杂度为O(n),删除时间复杂度为O(n)。即O(n)的时间内完成。 建立长度为256(char元素总数)的hash数组(类似基排序)，遍历key。即需要在source中删除的字符在hashtable上不为0。复杂度O(m)。 设定指针 temp和needDelete，初始化指向source. temp用来遍历source，任何时候指向不需要删除的字符。needDelete指向当前需要删除的第一个字符。 使用间接删除法。即将temp的值赋给source。 任何一轮循环。needDelete–temp-1的字符都可以被删除(即替代)。temp之前不需要删除的字符，都已经挪到needDelete之前。 以temp为空位结束条件。最后给needDelete赋空。 整体思路,从第一个删除的位置开始，依次把后面不需要删除的字符向前赋值。 1234567891011121314151617181920212223char *deleteStr(char *source, const char *key) &#123; if (!source || !key) return NULL; const char *temp = key; //static int hashTable[256]; int *hashTable = new int[256]; memset(hashTable, 0, 256 * sizeof(int)); while (*temp) hashTable[*temp++]++; temp = source; char *needDelete = source; while (*temp) &#123; if (!hashTable[*temp]) &#123;//不需要删除的字符，前移赋值 *needDelete = *temp; needDelete++; &#125; temp++; &#125; *needDelete = '\\0'; delete[]hashTable; return source;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Http通讯","date":"2016-12-18T16:00:00.000Z","path":"2016/12/19/http通信/","text":"Http简介 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 http的工作流程 浏览器分析连接所指向的页面URL。 浏览器向DNS请求解析URL的IP地址。 浏览器解析出服务器的IP地址。 浏览器与服务器建立TCP连接。 服务器给出相应的响应。 释放TCP连接。 http的三次握手 主机A发送位码syn=1,随机产生seq_number=1234567的数据包到服务器,主机B由syn=1指知道，A要求进行联机。 主机B收到请求后要确认联机信息xiang向A发送ack_number=(主机A的seq_number+1),syn=1,ack=1,随机产生seq=7654321. 主机A收到后检查ack_number是否正确，即第一次发送的seq_number+1,以及位码ack=1是否为1，若正确，主机A会再发送ack_number=(主机B的seq+1),ack=1, 主机B收到后确认seq值与ack=1则建立连接成功。 URLConnection 进行GET/POST请求1234567891011121314151617181920212223242526272829303132333435363738public void get() throws Exception &#123; URL url = new URL(\"http://127.0.0.1/\"); URLConnection urlConnection = url.openConnection(); // 打开连接 BufferedReader br = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(),\"utf-8\")); // 获取输入流 String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; sb.append(line + \"\\n\"); &#125; System.out.println(sb.toString());&#125;public void post() throws IOException&#123; URL url = new URL(\"http://127.0.0.1/\"); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setDoInput(true); httpURLConnection.setDoOutput(true); // 设置该连接是可以输出的 httpURLConnection.setRequestMethod(\"POST\"); // 设置请求方式 httpURLConnection.setRequestProperty(\"charset\", \"utf-8\"); PrintWriter pw = new PrintWriter(new BufferedOutputStream(httpURLConnection.getOutputStream())); pw.write(\"name=welcome\"); // 向连接中输出数据（相当于发送数据给服务器） pw.write(\"&amp;age=14\"); pw.flush(); pw.close(); BufferedReader br = new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream(),\"utf-8\")); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; // 读取数据 sb.append(line + \"\\n\"); &#125; System.out.println(sb.toString());&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"移位查找（day4）","date":"2016-12-17T16:00:00.000Z","path":"2016/12/18/everydayc/day4/","text":"题目 一个整型数组里除了两个数字之外，其他的数字都出现了两次。// 请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 思路 全部元素异或，结果一定不为0，且结果为只出现1次的元素的异或。 以第结果的第一个非0位(假设第N位)来看，所有元素在该位置的0,1都出现了奇数次。 以N为基准，为0的分为一组，为1的分为一组。则这两个数分别分到2组。 这两组分别异或，结果即为所求。 12345678910111213141516171819//函数功能 ： 找出数组中两个只出现一次的数字//函数参数 ： arr为源数组，len为数组元素个数，result用来存放结果void function1(int *arr, int len, int *result) &#123; int i, all = 0, flag = 1; for (int i = 0; i &lt; len; ++i) &#123; //所有数异或 all ^= arr[i]; &#125; while (!all &amp; flag) &#123; flag &lt;&lt;= 1; &#125; result[0] = result[1] = 0; //利用过滤位区分 for (i = 0; i &lt; len; i++) &#123; if (flag &amp; arr[i]) result[0] ^= arr[i]; else result[1] ^= arr[i]; &#125;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"java线程池源码分析","date":"2016-12-13T16:00:00.000Z","path":"2016/12/14/java-exectors/","text":"在什么情况下使用线程池 单个任务处理的时间比较短 将需处理的任务的数量大 1234greendao &#123; schemaVersion 1 targetGenDir 'src/main/java'&#125; 使用线程池的好处 减少在创建和销毁线程上所花的时间以及系统资源的开销 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存以及”过度切换” 案例112345678910111213public class Main &#123; private static Executor executor = Executors.newFixedThreadPool(10); public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++)&#123; executor.execute(new Task()); &#125; &#125; private static class Task implements Runnable&#123; public void run()&#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; Executor.newFixedThreadPool(10)初始化一个包含10个线程的executor; 通过executor.execute方法提交20个任务 负责执行任务的生命周期都由Executor框架进行管理 ThreadPoolExecutorExecutor是java线程池的工厂类**，通过它可以快速初始化一个符合业务需求的线程池，如Excutor.newFixedThreadPool方法可以生成一个拥有固定线程数的线程池。 1234567891011121314151617181920212223242526272829303132/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory and rejected execution handler. * It may be more convenient to use one of the &#123;@link Executors&#125; factory * methods instead of this general purpose constructor. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 其本质是通过不同的参数初始化一个ThreadPoolExecutor对象，具体参数描述如下： corePoolSize线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。 keepAliveTime线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用。 unitkeepAliveTime的单位。 workQueue用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列： ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务； LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene； SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene； priorityBlockingQuene：具有优先级的无界阻塞队列； threadFactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。 12345678DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; handler线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： AbortPolicy：直接抛出异常，默认策略； CallerRunsPolicy：用调用者所在的线程来执行任务； DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。 ExectorsExectors工厂类提供了线程池的初始化接口，主要有如下几种: newFixedThreadPool初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列，不过当线程池没有可执行任务时，也不会释放线程。1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newCachedThreadPool 初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列； 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销; 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; Java线程池的原理及几类线程池的介绍 深入分析java线程池的实现原理","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"MarkDowm命令","date":"2016-12-05T16:00:00.000Z","path":"2016/12/06/MarkDowm/","text":"标题1234# 一级标题## 二级标题### 三级标题... 有序列表12341. 列表2. 列表3. 列表... 无序列表123* 列表* 列表* 列表 引用1&gt; 这是一个引用 链接与图片123[baidu](www.baidu.com)![icon](http://ohqvqufyf.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD.jpeg) 字体123*这是斜体***这是粗体** 表格123| 表格1 | 表格2 ||--- |--- || 哈哈 | 呵呵 | code123void helloWorld()&#123; print(\"%s\", \"helloWorld\");&#125;","tags":[{"name":"MarkDowm","slug":"MarkDowm","permalink":"http://yoursite.com/tags/MarkDowm/"}]},{"title":"链表删除(day3)","date":"2016-12-04T16:00:00.000Z","path":"2016/12/05/everydayc/day3/","text":"假设链表……—A–B–C–D….，要删除B。一般的做法是遍历链表并记录前驱节点，修改指针，时间为O(n)。删除节点的实质为更改后驱指针指向。 这里，复制C的内容至B(此时B，C同时指向D)，删除节点C，即达到间接删除节点B的目的。 倘若B是链尾节点。则需要线性遍历寻找前驱节点。以上思路，时间复杂度为O(1)。123456789101112131415161718192021222324252627282930struct ListNode &#123; int m_nKey; ListNode *m_pNext;&#125;;void deleteNode(ListNode* pListHead, ListNode* pToBeDeleted) &#123; if (!pListHead || !pToBeDeleted) &#123; return; &#125; if (pListHead == pToBeDeleted)&#123; delete pListHead; pListHead = NULL; pToBeDeleted = NULL; &#125; else if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; ListNode* pNode = pListHead; while(pNode-&gt;m_pNext != pToBeDeleted) &#123; pNode = pNode-&gt;m_pNext; &#125; pNode-&gt;m_pNext = NULL; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Vim-command","date":"2016-12-04T16:00:00.000Z","path":"2016/12/05/vim-command/","text":"光标移动 命令 作用 h,j,k,l 左 下 右 上 Ctrl+f 上一页 Ctrl+b 下一页 w,e,W,E 调到单词后面，小写包括标点 O 开启新的一行 ^ 一行的开始 gg 文档的结尾 [N]G 文档的第N行或者最后一行 插入模式 命令 作用 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 编辑 命令 作用 r 在插入模式替换光标所在的一个字符 J 合并下一行到上一行 s 删除光标所在的一个字符，光标还在当行 S 删除光标所在的一行, 光标还在当行，不同于dd u 撤销上一步操作 ctrl+r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 [N]&gt;&gt; 一行或N行往右移动一个tab [N]&lt;&lt; 一行或N行往左移动一个tab 关闭 命令 作用 :q 保存 :wq, :x 保存并关闭 :q 关闭 :q! 强制关闭 搜索 命令 作用 /pattern 搜索(非插入模式) ?pattern 向后搜索 n 光标到达搜索结果的前一个目标 N 光标到达搜索结果的后一个目标 视觉模式 命令 模式 v 选中一个或多个字符 V 选中一行 剪切和复制 命令 作用 dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 窗口命令 命令 作用 : split 水平分割出一个窗口 :vsplit 垂直分割出一个窗口 :close 关闭窗口 ctrl+w 切换窗口 h,j,k,l 左下上右","tags":[{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}]},{"title":"位运算计数(day2)","date":"2016-11-19T16:00:00.000Z","path":"2016/11/20/everydayc/day2/","text":"题目: 求整数的2进制表示中1的个数整数 右移 相与123456789int function1(int i) &#123; int count = 0; while(i) &#123; if(i &amp; 1) count ++; i = i &gt;&gt; 1; &#125; return count;&#125; flag 左移 相与1234567891011int function2(int i) &#123; int count = 0; unsigned int flag = 1; while(flag)&#123; if(i &amp; flag)&#123; count ++; &#125; flag = flag &lt;&lt; 1; &#125; return count;&#125; 减一相与12345678int function3(int i) &#123; int count = 0; while (i) &#123; ++ count; i = (i - 1) &amp; i; &#125; return count;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Android Annotation使用","date":"2016-11-09T16:00:00.000Z","path":"2016/11/10/java-annotation/","text":"要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。 元注解 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： @Target @Retention @Documented @Inherited 这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。 @Target: @Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 12345678910111213141516171819202122232425262728/** Class, interface (including annotation type), or enum declaration */TYPE,/** Field declaration (includes enum constants) */FIELD,/** Method declaration */METHOD,/** Formal parameter declaration */PARAMETER,/** Constructor declaration */CONSTRUCTOR,/** Local variable declaration */LOCAL_VARIABLE,/** Annotation type declaration */ANNOTATION_TYPE,/** Package declaration */PACKAGE,/** * Type parameter declaration * * @since 1.8 */TYPE_PARAMETER,/** * Use of a type * * @since 1.8 */TYPE_USE 取值(ElementType)有： CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 使用实例: 12345678@Target(ElementType.TYPE)public @interface Table &#123; /** * 数据表名称注解，默认值为类名称 * @return */ public String tableName() default \"className\";&#125; 注解Table 可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。 @Retention： @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。M","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"递归加法(day1)","date":"2016-11-05T16:00:00.000Z","path":"2016/11/06/everydayc/day1/","text":"题目：求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C).使用函数指针1234567891011121314151617//-----&gt;fun1 start//使用函数指针 递归加法typedef int (*fun)(int);int func1(int n) &#123; return 0;&#125;int func2(int n) &#123; fun f[2] = &#123;func1, func2&#125;; return n + f[(n != 0)](n - 1);&#125;void function1() &#123; cout &lt;&lt; func2(10) &lt;&lt; endl;&#125;//-----&gt;fun2 end 使用静态变量1234567891011121314151617181920212223242526272829//-----&gt;fun2 start//使用静态变量class test &#123; static int N; static int sum;public : test() &#123; sum += ++N; &#125; static void reset() &#123; N = sum = 0; &#125; static int getSum() &#123; return sum; &#125;&#125;;int test::N = 0;int test::sum = 0;void function2() &#123; test::reset(); test *p = new test[10]; cout &lt;&lt; test::getSum() &lt;&lt; endl; delete[]p;&#125;//---&gt;fun2 end 使用虚函数的编译多态性123456789101112131415161718192021222324//-----&gt;fun3 start//使用虚函数的编译多态性class A &#123;public: virtual int sum(int n) &#123; return 0; &#125;;&#125;;class B : public A &#123;public: int sum(int n) &#123; A a; B b; A *p[2] = &#123;&amp;a, &amp;b&#125;; return n + p[(n - 1 != 0)]-&gt;sum(n - 1); &#125;&#125;;void function3() &#123; B b; cout &lt;&lt; b.sum(10) &lt;&lt; endl;&#125;//-----&gt;fun3 end 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"GreenDao使用详解","date":"2016-10-19T16:00:00.000Z","path":"2016/10/20/GreenDao使用基础/","text":"介绍官网地址 GreenDao github GreenDao 优点 性能高，号称Android最快的关系型数据库 内存占用小 库文件比较小，小于100K，编译时间低，而且可以避免65K方法限制 支持数据库加密 greendao支持SQLCipher进行数据库加密 有关SQLCipher可以参考这篇博客Android数据存储之Sqlite采用SQLCipher数据库加密实战 简洁易用的API GreenDao 3.0基本使用在.gradle添加依赖1234567891011121314buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' &#125;&#125;apply plugin: 'org.greenrobot.greendao'dependencies &#123; compile 'org.greenrobot:greendao:3.2.0'&#125; 需要配置数据库的基本属性 1234greendao &#123; schemaVersion 1 targetGenDir 'src/main/java'&#125; schemaVersion：数据库版本号 daoPackage：设置DaoMaster, DaoSession, Dao包名 targetGenDir: 设置DaoMaster, DaoSession, Dao目录 targetGenDirTest: 设置生成单元测试目录 generateTests 设置自动生成单元测试用例 创建实体123456789@Entity()public class User &#123; @Id private Long id; private String name; private int age; //省去了get/set方法&#125; 实体@Entity注解: schema：表示GreenDao当前实体属于哪个schema active: 标记一个实体处于活动状态，活动实体有更新，删除和刷新方法 nameInDb: 在数据中使用的别名，默认使用的是实名的类别 indexes: 定义索引，可以跨越多个列 createInDb: 标记创建数据库表 基础属性注解: @Id: 主键 Long型，可以通过@Id(autoincrement = true)设置自增长 @Property: 设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=”name”) @NotNul：设置数据库表当前列不能为空 @Transient ：添加次标记之后不会生成数据库表的列 索引注解: @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束 @Unique：向数据库列添加了一个唯一的约束 关系注解: @ToOne：定义与另一个实体（一个实体对象）的关系 @ToMany：定义与多个实体对象的关系 编译生成DaoMaster, DaoSession, Dao 创建一个数据库管理者单例 12345678910111213141516171819202122232425262728public class DBManager &#123; private final static String dbName = \"test_db\"; private static DBManager mInstance; private DaoMaster.DevOpenHelper openHelper; private Context context; public DBManager(Context context) &#123; this.context = context; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); &#125; /** * 获取单例引用 * * @param context * @return */ public static DBManager getInstance(Context context) &#123; if (mInstance == null) &#123; synchronized (DBManager.class) &#123; if (mInstance == null) &#123; mInstance = new DBManager(context); &#125; &#125; &#125; return mInstance; &#125;&#125; 获取可读可写数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 获取可读数据库 */private SQLiteDatabase getReadableDatabase() &#123; if (openHelper == null) &#123; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); &#125; return openHelper.getReadableDatabase();&#125;/** * 获取可写数据库 */private SQLiteDatabase getWritableDatabase() &#123; if (openHelper == null) &#123; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); &#125; return openHelper.getWritableDatabase();&#125;/** * 插入一条记录 * * @param user */public void insertUser(User user) &#123; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.insert(user);&#125;/** * 插入用户集合 * * @param users */public void insertUserList(List&lt;User&gt; users) &#123; if (users == null || users.isEmpty()) &#123; return; &#125; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.insertInTx(users);&#125;/** * 删除一条记录 * * @param user */public void deleteUser(User user) &#123; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.delete(user);&#125;/** * 更新一条记录 * * @param user */public void updateUser(User user) &#123; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.update(user);&#125;/** * 查询用户列表 */public List&lt;User&gt; queryUserList() &#123; DaoMaster daoMaster = new DaoMaster(getReadableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); QueryBuilder&lt;User&gt; qb = userDao.queryBuilder(); return qb.list();&#125;/** * 查询用户列表 */public List&lt;User&gt; queryUserList(int age) &#123; DaoMaster daoMaster = new DaoMaster(getReadableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); QueryBuilder&lt;User&gt; qb = userDao.queryBuilder(); qb.where(UserDao.Properties.Age.gt(age)).orderAsc(UserDao.Properties.Age); return qb.list();&#125; 外键使用(@ToOne, @ToMany)123456789101112131415@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; @NotNull private String name; private int age; private Long blogId; @ToOne(joinProperty = \"blogId\") private Blog blog;&#125; joinProperties这个参数是referencedJoinProperty 参数的升级版。在referencedJoinProperty参数中我们发现俩个实体关联的外键是CustomerId与id，但是如果我们的需求是外键不能通过id来定义，需要用自己自定义属性来定义，第一种方法就没法用了，而joinProperties就是为了解决这个需求的。 github源码 参考资料GreenDao 3.0使用 Android数据存储之GreenDao 3.0 详解 GreenDao3.0新特性解析（配置、注解、加密 史上最高效的ORM方案——GreenDao3.0高级用法","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"GitHub不允许上传大于100M文件问题","date":"2016-05-19T16:00:00.000Z","path":"2016/05/20/github上传问题/","text":"问题123456自己的项目的版本控制用的是Git，代码仓库在github托管。项目里用到了百度导航SDK，由于百度导航SDK有了新版本，于是就更新到了新版本，更新好了之后想把代码push到github上，结果出错了，被拒绝，具体信息是：Total 3007 (delta 664), reused 0 (delta 0)remote: error: GH001: Large files detected.remote: error: Trace: 7b7de6b9372ee392e0f3961b05ea6f33remote: error: See http://git.io/iEPt8g for more information.remote: error: File XXX/XXX/BaiduNaviSDK/libbaiduNaviSDK.a is 102.68 MB; this exceeds GitHub&apos;s file size limit of 100.00 MBTo https://github.com/XXX/XXXX.git。意思是有大文件，更多信息可到http://git.io/iEPt8g查看，文件libbaiduNaviSDK.a的大小超过了GitHub限制的100M大小。想要push，必须把这个文件移除，可是要怎么移除呢？ 解决方案第一种解决方案123456如果这个文件是最近一次commit的，并且你还没有push到github，那么第一步输入命令 cd /Users/Dora/Desktop/XXX（cd后面的这个路径要换成你自己项目的路径），然后第二步输入命令 git rm --cached /Users/Dora/Desktop/XXX/XXX/libbaiduNaviSDK.a（加下划线部分是你自己的要移除的文件的路径），第三步输入命令 git commit --amend -CHEAD，执行完这步后，这个大文件将会从你的commit记录里移除，并且以后commit都将不会再把它commit了，这时候就可以git push把本地代码push到github上了。 第二种解决方案用到一个叫BFG的工具。我们要到[https://rtyley.github.io/bfg-repo-cleaner/#download]这个网站去下载并学习如何使用这个工具123456789我们要cd进BFG文件所在目录，第一步输入命令java -jar bfg.jar --no-blob-protection --strip-blobs-bigger-than 50M my-repo.git（红色部分是你下载下来的文件的名字,蓝色部分是你需要移除的文件大小，橙色部分是你自己.git文件的路径），第二步cd my-repo.git ，第三步 git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive，第四步 git push，到此大功告成。你的commit历史里所有大于50M的文件的commit全部被清除，这样你就可以push到github上了。这里只是记录了怎么处理遇到的问题，如果想要知道原理，则需要好好好去学习学习。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]