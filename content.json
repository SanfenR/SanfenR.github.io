[{"title":"链表删除(day1)","date":"2016-12-13T16:00:00.000Z","path":"2016/12/14/everydayc/day3/","text":"假设链表……—A–B–C–D….，要删除B。一般的做法是遍历链表并记录前驱节点，修改指针，时间为O(n)。删除节点的实质为更改后驱指针指向。 这里，复制C的内容至B(此时B，C同时指向D)，删除节点C，即达到间接删除节点B的目的。 倘若B是链尾节点。则需要线性遍历寻找前驱节点。以上思路，时间复杂度为O(1)。123456789101112131415161718192021222324252627282930struct ListNode &#123; int m_nKey; ListNode *m_pNext;&#125;;void deleteNode(ListNode* pListHead, ListNode* pToBeDeleted) &#123; if (!pListHead || !pToBeDeleted) &#123; return; &#125; if (pListHead == pToBeDeleted)&#123; delete pListHead; pListHead = NULL; pToBeDeleted = NULL; &#125; else if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; ListNode* pNode = pListHead; while(pNode-&gt;m_pNext != pToBeDeleted) &#123; pNode = pNode-&gt;m_pNext; &#125; pNode-&gt;m_pNext = NULL; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"","date":"2016-12-13T03:14:00.000Z","path":"2016/12/13/java-exectors/","text":"在什么情况下使用线程池 单个任务处理的时间比较短 将需处理的任务的数量大 使用线程池的好处 减少在创建和销毁线程上所花的时间以及系统资源的开销 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存以及”过度切换” 案例112345678910111213public class Main &#123; private static Executor executor = Executors.newFixedThreadPool(10); public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++)&#123; executor.execute(new Task()); &#125; &#125; private static class Task implements Runnable&#123; public void run()&#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; Executor.newFixedThreadPool(10)初始化一个包含10个线程的executor; 通过executor.execute方法提交20个任务 负责执行任务的生命周期都由Executor框架进行管理 ThreadPoolExecutorExecutor是java线程池的工厂类**，通过它可以快速初始化一个符合业务需求的线程池，如Excutor.newFixedThreadPool方法可以生成一个拥有固定线程数的线程池。 1234567891011121314151617181920212223242526272829303132/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory and rejected execution handler. * It may be more convenient to use one of the &#123;@link Executors&#125; factory * methods instead of this general purpose constructor. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 其本质是通过不同的参数初始化一个ThreadPoolExecutor对象，具体参数描述如下： corePoolSize线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。 keepAliveTime线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用。 unitkeepAliveTime的单位。 workQueue用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列： ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务； LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene； SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene； priorityBlockingQuene：具有优先级的无界阻塞队列； threadFactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。 12345678DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; handler线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： AbortPolicy：直接抛出异常，默认策略； CallerRunsPolicy：用调用者所在的线程来执行任务； DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。 ExectorsExectors工厂类提供了线程池的初始化接口，主要有如下几种: newFixedThreadPool初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列，不过当线程池没有可执行任务时，也不会释放线程。1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newCachedThreadPool 初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列； 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销;123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; Java线程池的原理及几类线程池的介绍 深入分析java线程池的实现原理","tags":[]},{"title":"位运算计数(day2)","date":"2016-12-11T16:00:00.000Z","path":"2016/12/12/everydayc/day2/","text":"题目: 求整数的2进制表示中1的个数整数 右移 相与123456789int function1(int i) &#123; int count = 0; while(i) &#123; if(i &amp; 1) count ++; i = i &gt;&gt; 1; &#125; return count;&#125; flag 左移 相与1234567891011int function2(int i) &#123; int count = 0; unsigned int flag = 1; while(flag)&#123; if(i &amp; flag)&#123; count ++; &#125; flag = flag &lt;&lt; 1; &#125; return count;&#125; 减一相与12345678int function3(int i) &#123; int count = 0; while (i) &#123; ++ count; i = (i - 1) &amp; i; &#125; return count;&#125; 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"MarkDowm命令","date":"2016-12-06T03:50:30.000Z","path":"2016/12/06/MarkDowm/","text":"标题1234# 一级标题## 二级标题### 三级标题... 有序列表12341. 列表2. 列表3. 列表... 无序列表123* 列表* 列表* 列表 引用1&gt; 这是一个引用 链接与图片123[baidu](www.baidu.com)![icon](http://ohqvqufyf.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD.jpeg) 字体123*这是斜体***这是粗体** 表格123| 表格1 | 表格2 ||--- |--- || 哈哈 | 呵呵 | code123void helloWorld()&#123; print(\"%s\", \"helloWorld\");&#125;","tags":[{"name":"MarkDowm","slug":"MarkDowm","permalink":"http://yoursite.com/tags/MarkDowm/"}]},{"title":"递归加法(day1)","date":"2016-12-06T03:50:30.000Z","path":"2016/12/06/everydayc/day1/","text":"题目：求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C).使用函数指针1234567891011121314151617//-----&gt;fun1 start//使用函数指针 递归加法typedef int (*fun)(int);int func1(int n) &#123; return 0;&#125;int func2(int n) &#123; fun f[2] = &#123;func1, func2&#125;; return n + f[(n != 0)](n - 1);&#125;void function1() &#123; cout &lt;&lt; func2(10) &lt;&lt; endl;&#125;//-----&gt;fun2 end 使用静态变量1234567891011121314151617181920212223242526272829//-----&gt;fun2 start//使用静态变量class test &#123; static int N; static int sum;public : test() &#123; sum += ++N; &#125; static void reset() &#123; N = sum = 0; &#125; static int getSum() &#123; return sum; &#125;&#125;;int test::N = 0;int test::sum = 0;void function2() &#123; test::reset(); test *p = new test[10]; cout &lt;&lt; test::getSum() &lt;&lt; endl; delete[]p;&#125;//---&gt;fun2 end 使用虚函数的编译多态性123456789101112131415161718192021222324//-----&gt;fun3 start//使用虚函数的编译多态性class A &#123;public: virtual int sum(int n) &#123; return 0; &#125;;&#125;;class B : public A &#123;public: int sum(int n) &#123; A a; B b; A *p[2] = &#123;&amp;a, &amp;b&#125;; return n + p[(n - 1 != 0)]-&gt;sum(n - 1); &#125;&#125;;void function3() &#123; B b; cout &lt;&lt; b.sum(10) &lt;&lt; endl;&#125;//-----&gt;fun3 end 源码github","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Vim-command","date":"2016-12-06T03:27:38.000Z","path":"2016/12/06/vim-command/","text":"光标移动 命令 作用 h,j,k,l 左 下 右 上 Ctrl+f 上一页 Ctrl+b 下一页 w,e,W,E 调到单词后面，小写包括标点 O 开启新的一行 ^ 一行的开始 gg 文档的结尾 [N]G 文档的第N行或者最后一行 插入模式 命令 作用 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 编辑 命令 作用 r 在插入模式替换光标所在的一个字符 J 合并下一行到上一行 s 删除光标所在的一个字符，光标还在当行 S 删除光标所在的一行, 光标还在当行，不同于dd u 撤销上一步操作 ctrl+r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 [N]&gt;&gt; 一行或N行往右移动一个tab [N]&lt;&lt; 一行或N行往左移动一个tab 关闭 命令 作用 :q 保存 :wq, :x 保存并关闭 :q 关闭 :q! 强制关闭 搜索 命令 作用 /pattern 搜索(非插入模式) ?pattern 向后搜索 n 光标到达搜索结果的前一个目标 N 光标到达搜索结果的后一个目标 视觉模式 命令 模式 v 选中一个或多个字符 V 选中一行 剪切和复制 命令 作用 dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 窗口命令 命令 作用 : split 水平分割出一个窗口 :vsplit 垂直分割出一个窗口 :close 关闭窗口 ctrl+w 切换窗口 h,j,k,l 左下上右","tags":[{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}]}]